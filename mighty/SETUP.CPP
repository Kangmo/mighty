#include "hanbgi.h"
#include "han240.h"
#include "danbi.h"
#include "version.h"
#include "filebox.h"
#include "auxil.h"
#include <fstream.h>

#define SCRX 15
#define SCRY 10
#define SMX 4
#define SMY 5
#define MBC WLIGHTGREEN
#define MBKC WLIGHTGRAY
#define MAXMENU 300
#define GABX 4
#define MLINES 24
#define MAXX 7
#define SMEY 9
#define SMEX 40
#define NCDLINECOLOR WDARKGRAY
#define UPBARSTARTY 44
#define DNBARSTARTY 435
#define FS 127
#define VER 100
void Tempfunc()
{}

void MightyIs(), MailTo(), DosShell(), ExitPro(), Getport(), Getspeed(),
	  Getparity(), Getdata(), Getstop(), GetWaitInit(), GetLocalInit(),
	  GetInitGab(), GetsName(), GetsId(), GetbName(), GetInstDir(),
	  GetDownDir(), GetAnsiDir(),GetArcDir(),
	  GetLoginId(), GetSonnimLev(), GetJoinLev(), GetBbsPoint(),
	  GetUpPoint(), GetUpSizeRate(), GetUpTimeRate(), GetHanFontType(),
	  GetEngFontType(),GetHanBoard(), GetPeopleNum(), GetInputLimTime(),
	  GetVirDetect(), GetVirOrder(), GetHackDetect(), GetHackWord(),
	  GetOpMode(), GetDoNullModem(), GetOpStart(), GetOpEnd(), GetSmPass(),
	  MenuMake(), ProtoMake(), LevelMake(), GetSound(), GetSysopExist(),
	  GetFirstGrade(), GetGiveDnableSize(), GetSuccDnLoad(), GetFifo(),
	  GetFlow(), GetMinBbsSize(), GetMinPdsSize(), GetMinSpeed(),
	  GetUsePartTime(), GetEmulPro(), GetEditPro();
void ScreenInit();
void EditLevel( struct EditBox_ far *, int, int);
void ProtoEditBox(int );
void EditProto( struct EditBox_ far *, int, int, int );
void CopyString( char *, char *);
void EditMenu(void);
void ReadProtoFile();
int  multi(int, int );
void kmPuts(int ,int ,char *);
void CutOffSpace(unsigned char *str);

char *MNAME[21] = {
							"[비확정]",
							"[서브메뉴]",
							"[게시판]",
							"[자료실]",
							"[공개편지]",
							"[편지읽기]",
							"[편지쓰기]",
							"[편지보관함]",
							"[대화실]",
							"[가입메뉴]",
							"[회원검색]",
							"[자기정보관리]",
							"[시간은행] ",
							"[동호회관리]",
							"[공지사항]",
							"[스크립트]",
							"[CD-ROM 자료실]",
							"[RDN 자료실]" ,
							"[담당자수신편지]",
							"[보낸편지확인]",
							""};

void (*Embank[7][16])()={
				{MightyIs,MailTo,DosShell,Tempfunc,ExitPro,0},
				{Getport,Getspeed,Getparity,Getdata,Getstop,GetFifo,
				 GetFlow,Tempfunc, GetWaitInit,GetLocalInit,GetInitGab,
				 Tempfunc,GetMinSpeed,0},
				{GetsName,GetsId,GetbName,Tempfunc,GetSysopExist,
				 GetSound,Tempfunc,GetInstDir,GetDownDir,
				 GetAnsiDir,GetArcDir,0},
				{GetLoginId, GetSonnimLev, GetJoinLev, GetFirstGrade, Tempfunc,
				 GetBbsPoint, GetUpPoint, GetMinBbsSize, GetMinPdsSize, GetUpSizeRate,
				 GetUpTimeRate, GetGiveDnableSize, 0},
				{GetHanFontType, GetEngFontType, GetHanBoard, GetPeopleNum,
				 GetInputLimTime, Tempfunc, GetVirDetect, GetVirOrder,
				 GetHackDetect, GetHackWord, GetEmulPro, GetEditPro, Tempfunc,
				 GetSuccDnLoad, 0},
				{GetOpMode, GetDoNullModem, GetUsePartTime, GetOpStart, GetOpEnd, Tempfunc, GetSmPass,0},
				{MenuMake,ProtoMake,LevelMake,0}
};

//---------------------------------------------------------------------------
struct Proto {
		char Exec[13];
		char Up[31];
		char Dn[31];
		};


menu_t Menu[MAXMENU+1];
Proto Protocol[10];

char sName[11]="김강모",sId[9]="SYSOP",bName[11]="HAHA",
		 InstDir[41]="C:\\MIGHTY",
		 DownDir[41]="C:\\MIGHTY\\DOWN", AnsiDir[41]="C:\\MIGHTY\\ANSI",
		 ArcDir[41]="C:\\UTIL\\ARC", WaitInit[61]="ATZ", LocalInit[61]="ATZ",
		 LoginId[11]="마이티",
		 VirOrder[41]="C:\\UTIL\\VACCINE\\TV.EXE",
		 HackWord[41]="hack Hack HACK troy Troy TROY",
		 SmPass[9]="puhaha", SonnimLev[5]="30  ", JoinLev[5]="50  ",
		 BbsPoint[4]="3  ", UpPoint[4]="5  ", UpSizeRate[2]="2",
		 UpTimeRate[2]="1", InputLimTime[2]="5",
		 OpStart[9]="23시30분", OpEnd[9]="06시00분",  // for converting previous version.
		 OpStartHour[3]="23", OpStartMin[3]="00",
		 OpEndHour[3]="06", OpEndMin[3]="00",
		 InitGab[2]="5";
int    Version=100,port=2, speed=6, parity=0, data=1, stop=0,
		 HanFontType=1, EngFontType=1, VirDetect=0,
		 HackDetect=0, OpMode=0, PeopleNum=0,
		 HanBoard=0,LevelNo,DoNullModem=0,Sound=1,SysopExist=1,
		 FirstGrade=0, GiveDnableSize=0, SuccDnLoad=1, Fifo=2, Flow=0;
char   MinBbsSize[5]="0   ", MinPdsSize[5]="0   ",
		 MinSpeed[6]="0    ";
int    UsePartTime=0;
int    bExitPro =0;
char   EmulPro[41]="c:\\i\\i.exe";
char   EditPro[41]="c:\\utlt\\u.exe";
// empty objects for CFileSelect
class  _SCR SCR;
class  _rCOLOR rCOLOR;
int    st=0; // state of menu option. if st==0 -> Limit menu state.
				 //                       if st==1 -> UnLimit menu state.
             // This is used in EditMenu() function.
char Level[15][24]  = {
											"   0/  30/  20/   0",
											"   0/  50/  30/ 200",
											"  10/ 100/  35/ 300",
											"  20/ 200/  40/ 350",
											"  40/ 300/  45/ 400",
											"  60/ 400/  50/ 450",
											"  80/ 500/  55/ 500",
											" 100/ 600/  60/ 550",
											" 130/ 700/  65/ 600",
											" 200/ 800/  70/ 650",
											" 300/ 900/  75/ 700",
											" 400/1000/ 120/1000",
											"5000/2000/ 180/2000",
											"6000/5000/ 180/4000",
											"9000/9000/1000/9000"
							};
void SaveDatum(void)
{
	int i;
	int version;
	if (access("MIGHTY.cfg",0)!=-1)
		if (remove("MIGHTY.cfg")==-1)
		{
			closehan();
			printf("ERROR : Can't over write to mighty.cfg");
			exit(0);
		}
	version=IVER;
	fstream OutFile("Mighty.cfg",ios::out);
	for (i=0; i<15; i++)
		if ( !strcmp( Level[LevelNo=i], "    /    /    /    ") ) break;
	if ( strcmp( Level[14], "    /    /    /    ") ) LevelNo=15;
	OutFile<< version<< char(FS)<< port<< char(FS)<< speed<< char(FS)<< parity<< char(FS);
	OutFile<< data<< char(FS)<< stop<< char(FS)<< HanFontType<< char(FS);
	OutFile<< EngFontType<< char(FS)<< VirDetect<< char(FS);
	OutFile<< HackDetect<< char(FS)<< OpMode<< char(FS)<< PeopleNum<< char(FS);
	OutFile<< HanBoard<< char(FS)<<LevelNo<<char(FS)<< sName<< char(FS)<< sId<< char(FS);
	OutFile<< bName<< char(FS)<< InstDir<< char(FS)<< DownDir<<char(FS) ;
	OutFile<< AnsiDir<< char(FS)<< ArcDir<< char(FS)<< WaitInit<< char(FS);
	OutFile<< LocalInit<< char(FS);
	OutFile<< LoginId<< char(FS)<< VirOrder<< char(FS);
	OutFile<< HackWord<< char(FS)<< SmPass<< char(FS)<< SonnimLev<< char(FS);
	OutFile<< JoinLev<< char(FS)<< BbsPoint << char(FS);
	OutFile<< UpPoint<< char(FS)<< UpSizeRate <<char(FS)<< UpTimeRate<< char(FS);
	OutFile<< InputLimTime<< char(FS)<< OpStartHour << char(FS);
	OutFile<< OpStartMin<<char(FS)<<OpEndHour<< char(FS);
	OutFile<< OpEndMin<< char(FS)<< InitGab<<char(FS)<< DoNullModem << char(FS);
	OutFile<< Sound<< char(FS)<< SysopExist<< char(FS)<< FirstGrade<< char(FS);
	OutFile<< GiveDnableSize << char(FS)<< SuccDnLoad<< char(FS);
	OutFile<< Fifo<<char(FS)<< Flow<< char(FS);
	OutFile<< MinBbsSize<< char(FS)<< MinPdsSize<< char(FS);
	OutFile<< MinSpeed<< char(FS)<<UsePartTime<<char(FS);
	OutFile<< EmulPro<<char(FS)<< EditPro<<char(FS)<<'\n';

	for (i=0; i<15; i++)  OutFile<< Level[i] <<'\n';
	OutFile.close();
}

void Read10BDatum(void)
{
	 int j,count;
	 char ch, number[7];

	 fstream InFile("Mighty.cfg",ios::in);
	 if (!InFile) return;

	 count = -1; Version;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 Version += (number[j]-48)*multi(10, (count-j));


	 count = -1; port=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 port += (number[j]-48)*multi(10, (count-j));

	 count = -1; speed=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 speed += (number[j]-48)*multi(10, (count-j));

	 count = -1; parity=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		parity += (number[j]-48)*multi(10, (count-j));

	 count = -1; data=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 data += (number[j]-48)*multi(10, (count-j));

	 count = -1; stop=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 stop += (number[j]-48)*multi(10, (count-j));

	 count = -1; HanFontType=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 HanFontType += (number[j]-48)*multi(10, (count-j));

	 count = -1; EngFontType=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 EngFontType += (number[j]-48)*multi(10, (count-j));

	 count = -1; VirDetect=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 VirDetect += (number[j]-48)*multi(10, (count-j));

	 count = -1; HackDetect=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 HackDetect += (number[j]-48)*multi(10, (count-j));

	 count = -1; OpMode=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 OpMode += (number[j]-48)*multi(10, (count-j));

	 count = -1; PeopleNum=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 PeopleNum += (number[j]-48)*multi(10, (count-j));

	 count = -1; HanBoard=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 HanBoard += (number[j]-48)*multi(10, (count-j));

	 count = -1; LevelNo=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 LevelNo += (number[j]-48)*multi(10, (count-j));

		 count = -1;
		 while (InFile.get(ch), ch != FS) sName[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) sId[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) bName[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) InstDir[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) DownDir[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) AnsiDir[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) ArcDir[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) WaitInit[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) LocalInit[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) LoginId[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) VirOrder[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) HackWord[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) SmPass[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) SonnimLev[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) JoinLev[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS)
			  if (count < 2) BbsPoint[++count]=ch;
		 BbsPoint[3]=0;

		 count = -1;
		 while (InFile.get(ch), ch != FS)
			  if (count < 2) UpPoint[++count]=ch;
		 UpPoint[3]=0;

		 count = -1;
		 while (InFile.get(ch), ch != FS) UpSizeRate[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS)
			 if (count < 0) UpTimeRate[++count]=ch;
		 UpTimeRate[1]=0;

		 count = -1;
		 while (InFile.get(ch), ch != FS)
			 if (count < 0) InputLimTime[++count]=ch;
		 InputLimTime[1]=0;

		 count = -1;
		 while (InFile.get(ch), ch != FS) OpStart[++count]=ch;
		 OpStart[2]=OpStart[6]=0;
		 strcpy(OpStartHour,OpStart);
		 strcpy(OpStartMin, OpStart+4);

		 count = -1;
		 while (InFile.get(ch), ch != FS) OpEnd[++count]=ch;
		 OpEnd[2]=OpEnd[6]=0;
		 strcpy(OpEndHour,OpEnd);
		 strcpy(OpEndMin, OpEnd+4);

		 count = -1;
		 while (InFile.get(ch), ch != FS)
			  if (count<0) InitGab[++count]=ch;
		 InitGab[1] = 0;

		 count = -1; DoNullModem=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 DoNullModem += (number[j]-48)*multi(10, (count-j));

		 count = -1; Sound=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 Sound += (number[j]-48)*multi(10, (count-j));

		 count = -1; SysopExist=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 SysopExist += (number[j]-48)*multi(10, (count-j));

		 count = -1; FirstGrade=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 FirstGrade += (number[j]-48)*multi(10, (count-j));

		 count = -1; GiveDnableSize=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 GiveDnableSize += (number[j]-48)*multi(10, (count-j));

		 count = -1; SuccDnLoad=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 SuccDnLoad += (number[j]-48)*multi(10, (count-j));

		 count = -1; Fifo=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 Fifo += (number[j]-48)*multi(10, (count-j));

		 count = -1; Flow=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 Flow += (number[j]-48)*multi(10, (count-j));

		 count = -1;
		 while (InFile.get(ch), ch != FS) MinBbsSize[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) MinPdsSize[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS)
			 if (count < 4) MinSpeed[++count]=ch;
		 MinSpeed[5]=0;

		 count = -1; UsePartTime=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 UsePartTime += (number[j]-48)*multi(10, (count-j));

		 count = -1;
		 while (InFile.get(ch), ch != FS) EmulPro[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) EditPro[++count]=ch;

		 while( InFile.get(ch), ch!='\n');

		 for (int i=0; i<15; i++)
		 {
			 count = -1;
			 while (InFile.get(ch), ch != '\n') Level[i][++count]=ch;
		 }
		 // Do other initialization of new data.
	 InFile.close();
}
void Convert10BCfg()
{
		  char *pWin[] = {
					 " 마이티 1.0B버젼의 mighty.cfg ",
					 " 화일을 신버젼의 mighty.cfg로 ",
					 " 변환합니다.                  ",
					 "" };

	  Scr.SetSaveOn();
		  spMessageWin( -1, -1, "설정화일 변환중", pWin, WWHITE, WLIGHTRED);
	  Scr.SetSaveOff();

		  Read10BDatum();
		  SaveDatum();

		  delay(4000);
	  Scr.Restore();
}

void ReadDatum(void)
{
	 int j,count;
	 char ch, number[7];
	 int version;

	 fstream InFile("Mighty.cfg",ios::in);
	 if (!InFile) return;

	 count = -1; version=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
	 version += (number[j]-48)*multi(10, (count-j));
	 if (version==IVER)  // mighty 1.0 beta1.5 reading routine.
	 {
		  count = -1; port=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  port += (number[j]-48)*multi(10, (count-j));

		  count = -1; speed=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  speed += (number[j]-48)*multi(10, (count-j));

		  count = -1; parity=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			 parity += (number[j]-48)*multi(10, (count-j));

		  count = -1; data=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  data += (number[j]-48)*multi(10, (count-j));

		  count = -1; stop=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  stop += (number[j]-48)*multi(10, (count-j));

		  count = -1; HanFontType=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  HanFontType += (number[j]-48)*multi(10, (count-j));

		  count = -1; EngFontType=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  EngFontType += (number[j]-48)*multi(10, (count-j));

		  count = -1; VirDetect=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  VirDetect += (number[j]-48)*multi(10, (count-j));

		  count = -1; HackDetect=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  HackDetect += (number[j]-48)*multi(10, (count-j));

		  count = -1; OpMode=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  OpMode += (number[j]-48)*multi(10, (count-j));

		  count = -1; PeopleNum=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  PeopleNum += (number[j]-48)*multi(10, (count-j));

		  count = -1; HanBoard=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  HanBoard += (number[j]-48)*multi(10, (count-j));

		  count = -1; LevelNo=0;
		  while (InFile.get(ch), ch != FS) number[++count] = ch;
		  for (j=0; j<=count; j++)
			  LevelNo += (number[j]-48)*multi(10, (count-j));

			  count = -1;
			  while (InFile.get(ch), ch != FS) sName[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) sId[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) bName[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) InstDir[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) DownDir[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) AnsiDir[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) ArcDir[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) WaitInit[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) LocalInit[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) LoginId[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) VirOrder[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) HackWord[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) SmPass[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) SonnimLev[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) JoinLev[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) BbsPoint[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) UpPoint[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) UpSizeRate[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) UpTimeRate[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) InputLimTime[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) OpStartHour[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) OpStartMin[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) OpEndHour[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) OpEndMin[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) InitGab[++count]=ch;

			  count = -1; DoNullModem=0;
			  while (InFile.get(ch), ch != FS) number[++count] = ch;
			  for (j=0; j<=count; j++)
			  DoNullModem += (number[j]-48)*multi(10, (count-j));

			  count = -1; Sound=0;
			  while (InFile.get(ch), ch != FS) number[++count] = ch;
			  for (j=0; j<=count; j++)
			  Sound += (number[j]-48)*multi(10, (count-j));

			  count = -1; SysopExist=0;
			  while (InFile.get(ch), ch != FS) number[++count] = ch;
			  for (j=0; j<=count; j++)
			  SysopExist += (number[j]-48)*multi(10, (count-j));

			  count = -1; FirstGrade=0;
			  while (InFile.get(ch), ch != FS) number[++count] = ch;
			  for (j=0; j<=count; j++)
			  FirstGrade += (number[j]-48)*multi(10, (count-j));

			  count = -1; GiveDnableSize=0;
			  while (InFile.get(ch), ch != FS) number[++count] = ch;
			  for (j=0; j<=count; j++)
			  GiveDnableSize += (number[j]-48)*multi(10, (count-j));

			  count = -1; SuccDnLoad=0;
			  while (InFile.get(ch), ch != FS) number[++count] = ch;
			  for (j=0; j<=count; j++)
			  SuccDnLoad += (number[j]-48)*multi(10, (count-j));

			  count = -1; Fifo=0;
			  while (InFile.get(ch), ch != FS) number[++count] = ch;
			  for (j=0; j<=count; j++)
			  Fifo += (number[j]-48)*multi(10, (count-j));

			  count = -1; Flow=0;
			  while (InFile.get(ch), ch != FS) number[++count] = ch;
			  for (j=0; j<=count; j++)
			  Flow += (number[j]-48)*multi(10, (count-j));

			  count = -1;
			  while (InFile.get(ch), ch != FS) MinBbsSize[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) MinPdsSize[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) MinSpeed[++count]=ch;

			  count = -1; UsePartTime=0;
			  while (InFile.get(ch), ch != FS) number[++count] = ch;
			  for (j=0; j<=count; j++)
			  UsePartTime += (number[j]-48)*multi(10, (count-j));

			  count = -1;
			  while (InFile.get(ch), ch != FS) EmulPro[++count]=ch;

			  count = -1;
			  while (InFile.get(ch), ch != FS) EditPro[++count]=ch;

			  while( InFile.get(ch), ch!='\n');

			  for (int i=0; i<15; i++)
			  {
				  count = -1;
				  while (InFile.get(ch), ch != '\n') Level[i][++count]=ch;
			  }
		  InFile.close();
	 }
	 // insert any other version reading routine
	 else
	 {
			  InFile.close();
			  Convert10BCfg();
	 }
}

class PullDown_ far * PD;
//---------------------------------------------------------------------------


void PullDownRtn(void);
void userinithan(void);

void MightyIs()
{
	char *pWin[] = {
		" 새로운 호스트 마이티는 객체지향 ",
		" 기법을 사용, 제작 되었으므로 향 ",
		" 후 활발한 버젼업이 가능합니다.  ",
		" 마이티는 공개 소프트웨어이며, 상",
		" 업적 목적으로 쓰일 수 없습니다. ",
		"                                 ",
		"   Mighty Host   ver 1.0 beta1.5 ",
		"     (저) REFINED  SOFTWARE      ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "마이티는..", pWin, WWHITE, WLIGHTBLUE);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}
// Path Buffer is in FILEBOX module.
extern char PathBuffer[200];
void InitData()
{
	 CutOffSpace(AnsiDir);
	 sprintf( PathBuffer, "%s\\*.*",AnsiDir);
}
void main(int argc, char* argv[])
{
	 if (argc >= 2)
		 if (!stricmp(argv[1], "/a")) st =1;
	 if (spDanbiInit(0L) == -1) return;
	 userinithan();
	 meq_init (MOU_ARROW16);
	 meq_show();
	 ReadDatum();
	 ReadProtoFile();
	 InitData();
	 PullDownRtn();
	 mou_close();
}
void userinithan()
{
		 LINK_EGA_hputfont8x16();
		 LINK_EGA_hputfont16x16();
		 // debug - HANVGA --> HANDETECT
		 inithanlib( BGIMODE, HANVGA, HAN8GD1, ENGMD1);
		 SELECT_hputfont8x16(AUTOSELECT);
		 SELECT_hputfont16x16(AUTOSELECT);
		 hsetallcolormap();
		 hsetwindowspalette(0);
}
/*
void Mighty()
{
	int 	x = 315 - 151,
		y = 240 - 110,
		handle = Scr.GetImage( x, y, x+312, y+220 );

	if( handle > 0)
		spPcxView16( x, y, "danbi35.pcx" );
	if( handle > 0)
	{
		spWait();

		Scr.PutImage( handle, x, y );
		Scr.HanFree( handle );
	}
}*/

void PullDownRtn()
{
		 PD = new PullDown_(0, hgetmaxpx(), 0, WBLACK, WWHITE);
		 int pd_x, pd_y;

		 char far *PopTitle[] = {
								"마이티",
								"모뎀셋업",
								"운영셋업",
								"BBS 셋업",
								"부가셋업I",
								"부가셋업II",
								"편집기",
								""};
		 int PopX[] = {SCRX, SCRX+90, SCRX+180, SCRX+270, SCRX+360,
									 SCRX+450, SCRX+540, 0};
		 int PopState[] = { 1, 1, 1, 1, 1, 1, 1, 0};

		 char far *PopMenu[7][16] = {
						 {
							 "마이티는..",
							 "제  작  자",
							 "도  스  쉘",
							 "LINE",
							 "끝  내  기",
							 ""},
						 {
							 "모 뎀  포 트",
							 "모 뎀  속 도",
							 "패리티  비트",
							 "데이타  비트",
							 "정 지  비 트",
							 " 16550 FIFO ",
							 "흐 름  제 어",
							 "LINE",
							 "대기중초기화",
							 "로컬  초기화",
							 "초기화  간격",
							 "LINE",
							 "최저접속속도",
							 ""},
						 {
							 "운영자   이름",
							 "운영자 아이디",
							 "비비에스 이름",
							 "LINE",
							 "운영자   유무",
							 "호스트   소리",
							 "LINE",
							 "설치된   경로",
							 "자료실   경로",
							 "안시화일 경로",
							 "압축화일 경로",
							 ""},
						 {
							 "로그인  아이디",
							 "손  님  레  벨",
							 "등 록 시  레벨",
							 "등 록 시  등급",
							 "LINE",
							 "게시판작성점수",
							 "자료업로드점수",
							 "게시물최저크기",
							 "자료 최저 크기",
							 "업로드용량보상",
							 "업로드시간보상",
							 "일일    다운제",
							 ""},
						 {
							 "한글  글꼴  지정",
							 "영문  글꼴  지정",
							 "한글  자판  지정",
							 "주민등록번호확인",
							 "입력  제한  시간",
							 "LINE",
							 "바이러스검사여부",
							 "바이러스검사명령",
							 "해킹자료검사여부",
							 "해킹자료  검색어",
							 "통신  에뮬레이터",
							 "에     디     터",
							 "LINE",
							 "연속  다운  로드",
							 ""},
						 {
							 "운 영  모 드",
							 "널모뎀  운영",
							 "파트타임사용",
							 "운영시작시각",
							 "운영종료시각",
							 "LINE",
							 "시삽메뉴암호",
							 ""},
						 {
							 "메    뉴",
							 "프로토콜",
							 "레    벨",
							 ""},
		 };

		 int PopMenuState[7][16] = {
								 { 1, 1, 1,-1, 1, 0},
								 { 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1,-1, 1, 0},
								 { 1, 1, 1,-1, 1, 1,-1, 1, 1, 1, 1, 0},
								 { 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1, 1, 0},
								 { 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 0},
								 { 1, 1, 1, 1, 1,-1, 1, 0},
								 { 1, 1, 1, 0},
		 };
		 PD->TopMenu = PopTitle;
		 PD->TopX = PopX;
		 PD->TopState = PopState;

		 for ( int i=0; i < 7; i++) {
				PD->PopMenuSet( PopMenu[i], i);
				PD->PopStateSet( PopMenuState[i], i);
		 }
		 ScreenInit();
		 PD->TopMenuInit(0);
		 MightyIs();
		 int flag;
		 _cuttail=true;  // for cutting space. this is hanlapro global variable.
		 for (;;) {
							 flag=PD->TopMenuSelect();
							 pd_x = PD->X();
							 pd_y = PD->Y();
							 if ( flag != -1)
							 {
								 (*Embank[pd_x][pd_y])();
								 PD->TopMenuInit(PD->X());
								 if (bExitPro) break;
							 }
		 };
		 delete PD;
}

void spmyGetMunja(int x, int y, char* str, char* prt, char* pic, char* spec)
{
	hgotopxy(x+strlen(pic)*8,y);
	hputs(prt);
	spGetMunja(x, y, str, pic, spec);
}

void MailTo()
{
	char *pWin[] = {
		"                                    ",
		"    Mighty HOST  ver 1.0 beta1.5    ",
		"        만  든  이 : 김강모         ",
		"        하이텔  Id : Capcom         ",
		"        나우콤  Id : refined        ",
		"                                    ",
		"     고려대학교 컴퓨터학과 '95      ",
		"                                    ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "제 작 자", pWin, WWHITE, WLIGHTBLUE);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}

void ScreenInit()
{
	spPcxView16(0, 0, "screen.pcx");
	spBar3d1(0,DNBARSTARTY,639,475);
	kmPuts(3,29,"#7@1 MIGHTY @10ver 1.0 beta1.5  [ 향후 윈95용 멀티로 변환 예정 ]       @9(저) @4김강모");
}
void DosShell()
{
	mou_hide();
	hrestorecrtmode();
	textcolor( WLIGHTGREEN );
	cputs( "<<<<");
	textcolor( WWHITE );
	cputs( "  MIGHTY  Ver 1.0 beta1.5");
	textcolor( WLIGHTGREEN );
	cputs( " >>>>" );
	system("");
	hsetgraphmode();
	hsetwindowspalette(0);
	ScreenInit();
	mou_show();
}

void ExitPro()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"예",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "종료 하시겠습니까?",
																			pMessage, pItem, 0);
	Scr.SetSaveOff();
	Scr.Restore();


	if ( flag ==  1 ) {
										SaveDatum();
										bExitPro =1;
										}
}
void Getport()
{
	char far *pMenu[5] = {
				 "    1  번    ",
				 "    2  번    ",
				 "    3  번    ",
				 "    4  번    ",
				 ""};


	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 4, "모뎀 포트", pMenu, port);
	Scr.SetSaveOff();

	if ( flag != -1 ) port=flag;
	Scr.Restore();
}
void Getspeed()
{
	char far *pMenu[11]= {
				 "      300    ",
				 "      600    ",
				 "     1200    ",
				 "     2400    ",
				 "     4800    ",
				 "     9600    ",
				 "    19200    ",
				 "    38400    ",
				 "    57600    ",
				 "   115200    ",
				 ""};


	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 10, "모뎀속도", pMenu, speed);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) speed=flag;
	Scr.Restore();
}
void Getparity()
{
	char far *pMessage[] = {
							 "                       ",
							 ""};
	char far *pItem[] = {
								"없다",
								" ODD",
								"EVEN",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "패리티 비트", pMessage, pItem, parity);
	Scr.SetSaveOff();
	if ( flag != -1 ) parity = flag;
	Scr.Restore();
}

void Getdata()
{
	char far *pMessage[] = {
							 "                  ",
							 ""};
	char far *pItem[] = {
								"7 비트",
								"8 비트",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "데이터 비트", pMessage, pItem, data);
	Scr.SetSaveOff();
	if ( flag != -1 ) data = flag;
	Scr.Restore();
}
void Getstop()
{
	char far *pMessage[] = {
							 "                  ",
							 ""};
	char far *pItem[] = {
								"1 비트",
								"2 비트",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "스톱 비트", pMessage, pItem, stop);
	Scr.SetSaveOff();
	if ( flag != -1 ) stop =flag;
	Scr.Restore();
}

void GetWaitInit()
{
	int x=100,y=200;
	bool temp = _hangulmode;
	_hangulmode = false;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+502, y+50, "접속 대기중 초기화명령" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, WaitInit,
			 "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-60s" );
	_hangulmode = temp;

	Scr.Restore();
}
void GetLocalInit()
{
	int x=100,y=220;
	bool temp=_hangulmode;
	_hangulmode=false;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+342, y+50, "로컬 접속시 초기화명령" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, LocalInit,
			 "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	_hangulmode = temp;
	Scr.Restore();
}
void GetInitGab()
{
	int x=190,y=198;
	Scr.SetSaveOn();
	spBoxWin( x, y, x+136, y+50, "초기화 간격" );
	Scr.SetSaveOff();


	spmyGetMunja( x+10, y+29, InitGab,"분", "9", "%-1s" );
	Scr.Restore();
}

void GetsName()
{
	int x=190,y=140;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+120, y+50, "시삽 이름" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, sName,"XXXXXXXXXX", "%-10s" );
	Scr.Restore();
}
void GetsId()
{
	int x=190,y=156;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+136, y+50, "시삽 아이디");
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, sId,"XXXXXXXX", "%-8s" );
	Scr.Restore();
}
void GetbName()
{
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+120, y+50, "BBS 이름" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, bName,"XXXXXXXXXX", "%-10s" );
	Scr.Restore();
}
void GetInstDir()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "마이티가 설치된 경로" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, InstDir,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
	_hangulmode=temp;

	/*
	spBoxWin( 221, 210, 561, 264, "마이티가 설치된 경로");
	Scr.SetSaveOff();

	kmPuts(30,16,"#10                                        ");
	hgotoxy(30,16);
	hgetln(InstDir, 40);

	_hangulmode = temp;
	Scr.Restore();
	*/
}
void GetDownDir()
{
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "자료실 경로" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, DownDir,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();

}
void GetAnsiDir()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "안시화일이 있는 경로" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, AnsiDir,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();

}
void GetArcDir()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "압축화일이 있는 경로" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, ArcDir,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();

}
void GetLoginId()
{
	int x=280,y=102;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+150, y+50, "로그인 아이디" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, LoginId,"XXXXXXXXXX", "%-10s" );
	Scr.Restore();
}
void GetSonnimLev()
{
	int x=280,y=118;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+126, y+50, "손님 레벨" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, SonnimLev,"9999", "%-4s" );
	Scr.Restore();
}
void GetJoinLev()
{
	int x=280,y=134;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+150, y+50, "등록시 레벨" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, JoinLev,"9999", "%-4s" );
	Scr.Restore();
}
void GetBbsPoint()
{
	int x=280,y=150;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+180, y+50, "게시판 작성점수" );
	Scr.SetSaveOff();

	spmyGetMunja(x+10, y+29, BbsPoint, "점", "999", "%-3s");
	Scr.Restore();
}
void GetUpPoint()
{
	int x=280,y=166;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+186, y+50, "자료 업로드 점수" );
	Scr.SetSaveOff();

	spmyGetMunja( x+10, y+29, UpPoint,"점","999", "%-3s" );
	Scr.Restore();
}
void GetUpSizeRate()
{
	int x=280,y=182;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+210, y+50, "업로드 용량 보상비" );
	Scr.SetSaveOff();
	hprintfpxy( x+10+8, y+29, "배");
	spGetMunja( x+10, y+29, UpSizeRate,"9", "%-1s" );
	Scr.Restore();
}
void GetUpTimeRate()
{
	int x=280,y=198;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+210, y+50, "업로드 시간 보상비" );
	Scr.SetSaveOff();

	spmyGetMunja( x+10, y+29, UpTimeRate,"배", "9", "%-1s" );
	Scr.Restore();
}
void GetHanFontType()
{
	 loadhanfont(1, "han8gd1.fnt", HINFO8X4X4);
	 loadhanfont(2, "han10md1.fnt", HINFO10X4X4);
	 loadhanfont(3, "han8gd2.fnt", HINFO8X4X4);
	 loadhanfont(4, "han8gd3.fnt", HINFO8X4X4);
	 loadhanfont(5, "han8gs1.fnt", HINFO8X4X4);
	 loadhanfont(6, "han8gs2.fnt", HINFO8X4X4);

		class PopUp_  SelectingFont;
		int flag;
		char far *pMenu[7] = {
					 "  한글 글꼴 1번  ",
					 "  한글 글꼴 2번  ",
					 "  한글 글꼴 3번  ",
					 "  한글 글꼴 4번  ",
					 "  한글 글꼴 5번  ",
					 "  한글 글꼴 6번  ",
					 ""};



		int PopMenuState[7] = { 1, 1, 1, 1, 1, 1, 0 };

		Scr.SetSaveOn();
			 spWin( 305, 139, 421, 245, "");
		Scr.SetSaveOff();

			 spBoxFill( 305, 139, 421, 245 , WLIGHTBLUE);
			 spBoxLine( 305, 139, 421, 245 , WWHITE,WDARKBLUE);

			 changehanfont(1);
			 kmPuts(40,10,"#9@15한글글꼴 1번");
			 changehanfont(2);
			 kmPuts(40,11,"#9@15한글글꼴 2번");
			 changehanfont(3);
			 kmPuts(40,12,"#9@15한글글꼴 3번");
			 changehanfont(4);
			 kmPuts(40,13,"#9@15한글글꼴 4번");
			 changehanfont(5);
			 kmPuts(40,14,"#9@15한글글꼴 5번");
			 changehanfont(6);
			 kmPuts(40,15,"#9@15한글글꼴 6번");

		Scr.SetSaveOn();
			 SelectingFont.PopUp( 150, 139, WWHITE, WBLACK, pMenu, PopMenuState);
		Scr.SetSaveOff();

		flag = SelectingFont.PopUpSelect();

		if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) )
		{
			 HanFontType = flag + 1;
			 changehanfont( HanFontType ) ;
			 int count = 1;
			 while (count ++ <= 6)
					if ( count != HanFontType ) releasehanfont(count);
			 ScreenInit();
		}
		else {
			 Scr.Restore();
			 Scr.Restore();
		}
}

void GetEngFontType()
{
	 loadengfont(1, "engmd2.fnt");
	 loadengfont(2, "engmd1.fnt");
	 loadengfont(3, "engmd3.fnt");
	 loadengfont(4, "engmd4.fnt");
	 loadengfont(5, "engmd6.fnt");
	 loadengfont(6, "enggd5.fnt");
	 loadengfont(7, "enggs6.fnt");


		class PopUp_  SelectingFont;
		int flag;
		char far *pMenu[8] = {
					 "  영문 글꼴 1번  ",
					 "  영문 글꼴 2번  ",
					 "  영문 글꼴 3번  ",
					 "  영문 글꼴 4번  ",
					 "  영문 글꼴 5번  ",
					 "  영문 글꼴 6번  ",
					 "  영문 글꼴 7번  ",
					 ""};



		int PopMenuState[8] = { 1, 1, 1, 1, 1, 1, 1, 0 };

		Scr.SetSaveOn();
			 spWin( 305, 139, 421, 261, "");
		Scr.SetSaveOff();

			 spBoxFill( 305, 139, 421, 261 , WLIGHTBLUE);
			 spBoxLine( 305, 139, 421, 261 , WWHITE,WDARKBLUE);

			 changeengfont(1);
			 kmPuts(40,10,"#9@15ENGLISH NO 1");
			 changeengfont(2);
			 kmPuts(40,11,"#9@15ENGLISH NO 2");
			 changeengfont(3);
			 kmPuts(40,12,"#9@15ENGLISH NO 3");
			 changeengfont(4);
			 kmPuts(40,13,"#9@15ENGLISH NO 4");
			 changeengfont(5);
			 kmPuts(40,14,"#9@15ENGLISH NO 5");
			 changeengfont(6);
			 kmPuts(40,15,"#9@15ENGLISH NO 6");
			 changeengfont(7);
			 kmPuts(40,16,"#9@15ENGLISH NO 7");

		Scr.SetSaveOn();
			 SelectingFont.PopUp( 150, 139, WWHITE, WBLACK, pMenu, PopMenuState);
		Scr.SetSaveOff();

		flag = SelectingFont.PopUpSelect();

		if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) )
		{
			 EngFontType = flag + 1;
			 changeengfont( EngFontType ) ;
			 int count = 1;
			 while (count ++ <= 7) if ( count != EngFontType ) releaseengfont(count);
			 ScreenInit();
		}
		else {
			 Scr.Restore();
			 Scr.Restore();
		}


}
void GetHanBoard()
{
	char far *pMessage[] = {
							 " 사용하고자 하는 한글 ",
							 " 자판을 결정해 주세요 ",
							 ""};
	char far *pItem[] = {
								"2벌식",
								"3벌식",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "한글 자판",pMessage, pItem, HanBoard);
	Scr.SetSaveOff();

	if ( flag != -1)
	{
		 HanBoard = flag;
		 if ( HanBoard == 0 )
		 {
			 hsethan389board( false );
			 hsethan2board( true );
		 }
		 else if ( HanBoard == 1 )
		 {
			 hsethan2board( false );
			 hsethan389board( true );
		 }
	}
	Scr.Restore();


}

void GetPeopleNum()
{
	char far *pMessage[] = {
							 "                    ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "주민등록번호 검사",
																		pMessage, pItem, PeopleNum);
	Scr.SetSaveOff();
	if ( flag != -1 ) PeopleNum = flag;
	Scr.Restore();
}

void GetInputLimTime()
{
	int x=350,y=220;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+144, y+50, "입력제한시간" );
	Scr.SetSaveOff();

	spmyGetMunja( x+10, y+29, InputLimTime,"분", "9", "%-1s" );
	Scr.Restore();
}
void GetVirDetect()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "바이러스 검사", pMessage, pItem, VirDetect);
	Scr.SetSaveOff();
	if ( flag != -1 ) VirDetect = flag;
	Scr.Restore();
}

void GetVirOrder()
{

	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "바이러스 검사 명령" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, VirOrder,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
	_hangulmode = temp;
}
void GetHackDetect()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "해킹,트로이 자료검사",
																			pMessage, pItem, HackDetect);
	Scr.SetSaveOff();
	if ( flag != -1 ) HackDetect = flag;
	Scr.Restore();
}

void GetHackWord()
{
	int x=145,y=220;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+342, y+50, "해킹자료 검사 단어" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, HackWord,
			 "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
}
void GetOpMode()
{
	char far *pMessage[] = {
							 "                             ",
							 ""};
	char far *pItem[] = {
								"공개",
								"반공개",
								"비공개",
								""};

	Scr.SetSaveOn();

	int flag = spChoiceItemWin(-1, -1, "운영 모드", pMessage, pItem, OpMode);
	Scr.SetSaveOff();
	if ( flag != -1 ) OpMode = flag;
	Scr.Restore();
}
void GetDoNullModem()
{
	char far *pMessage[] = {
							 "널모뎀통신은 모뎀없이 하는 통신입니다",
							 "전화선을 이용하여 운영할시 \"안한다\"로",
							 "설정하셔야 합니다.",
							 "널모뎀으로 호스트를 운영하시겠습니까?",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();

	int flag = spChoiceItemWin(-1, -1, "널모뎀 운영", pMessage, pItem, DoNullModem);
	Scr.SetSaveOff();
	if ( flag != -1 ) DoNullModem = flag;
	Scr.Restore();

}
void GetOpStart()
{
	int x=460,y=120;

	char far *pMenu[3] = {
				 "        시간        ",
				 "         분         ",
				 ""};
	Scr.SetSaveOn();
	int flag=spPopUpWin( x-60, y-60, 2, "운영시작 시각", pMenu, 0);
	Scr.SetSaveOff();

	switch( flag )
	{
		case 0 :
				Scr.SetSaveOn();
				spBoxWin( x, y, x+100, y+50, "시간" );
				Scr.SetSaveOff();

				spmyGetMunja( x+20, y+29, OpStartHour, "시", "99", "%-2s" );
				Scr.Restore();
				break;
		case 1 :
				Scr.SetSaveOn();
				spBoxWin( x, y, x+100, y+50, "분" );
				Scr.SetSaveOff();

				spmyGetMunja( x+20, y+29, OpStartMin, "분", "99", "%-2s" );
				Scr.Restore();
				break;
	}

	Scr.Restore();

}
void GetOpEnd()
{
	int x=460,y=130;

	char far *pMenu[3] = {
				 "        시간        ",
				 "         분         ",
				 ""};
	Scr.SetSaveOn();
		  int flag=spPopUpWin( x-60, y-60, 2, "운영종료 시각", pMenu, 0);
	Scr.SetSaveOff();

	switch( flag )
	{
		case 0 :
				Scr.SetSaveOn();
				spBoxWin( x, y, x+100, y+50, "시간" );
				Scr.SetSaveOff();

				spmyGetMunja( x+20, y+29, OpEndHour, "시", "99", "%-2s" );
				Scr.Restore();
				break;
		case 1 :
				Scr.SetSaveOn();
				spBoxWin( x, y, x+100, y+50, "분" );
				Scr.SetSaveOff();

				spmyGetMunja( x+20, y+29, OpEndMin, "분", "99", "%-2s" );
				Scr.Restore();
				break;
	}

	Scr.Restore();
}
void GetSmPass()
{
	int x=460,y=140;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+120, y+50, "RDS 암호" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, SmPass, "XXXXXXXX", "%-8s" );
	Scr.Restore();
}
void GetSound()
{
	char far *pMessage[] = {
							 "BBS 운영시 호스트의 소리",
							 "를 꺼놓겠습니까?  켜놓겠",
							 "습니까?",
							 ""};
	char far *pItem[] = {
								"끔",
								"켬",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "호스트 소리",
																			pMessage, pItem, Sound);
	Scr.SetSaveOff();
	if ( flag != -1 ) Sound = flag;
	Scr.Restore();
}
void GetSysopExist()
{
	char far *pMessage[] = {
							 "                  ",
							 ""};
	char far *pItem[] = {
								"없음",
								"있음",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "운영자 유무",
																			pMessage, pItem, SysopExist);
	Scr.SetSaveOff();
	if ( flag != -1 ) SysopExist = flag;
	Scr.Restore();
}
void GetFirstGrade()
{
	char far *pMenu[11]= {
								"   사용중지회원   ",
								"     비 회 원     ",
								"     회 원  3     ",
								"     회 원  2     ",
								"     회 원  1     ",
								"     정 회 원     ",
								"     부운영자     ",
								"     운 영 자     ",
								""};

	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 8, "등록시  등급", pMenu, FirstGrade);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) FirstGrade=flag;
	Scr.Restore();
}
void GetGiveDnableSize()
{
	char far *pMessage[] = {
							 "                  ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "일일 다운제 사용",
																			pMessage, pItem, GiveDnableSize);
	Scr.SetSaveOff();
	if ( flag != -1 ) GiveDnableSize = flag;
	Scr.Restore();
}
void GetSuccDnLoad()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "연속 다운로드 사용",
																			pMessage, pItem, SuccDnLoad);
	Scr.SetSaveOff();
	if ( flag != -1 ) SuccDnLoad = flag;
	Scr.Restore();
}
void GetFifo()
{
	char far *pMenu[11]= {
								"   사용 안함   ",
								"    1 byte     ",
								"    4 bytes    ",
								"    8 bytes    ",
								"   14 bytes    ",
								""};

	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 5, "16550 FIFO", pMenu, Fifo);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) Fifo=flag;
	Scr.Restore();
}
void GetFlow()
{
	char far *pMenu[11]= {
								"         사용  안함          ",
								"     하드 웨어  흐름제어     ",
								"     소프트웨어 흐름제어     ",
								"         둘다  사용          ",
								""};

	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 4, "흐름 제어(Flow Control)", pMenu, Flow);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) Flow=flag;
	Scr.Restore();

}
void GetMinBbsSize()
{
	int x=250,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+240, y+50, "최저게시물크기 (글자수)" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, MinBbsSize,"9999", "%-4s" );
	Scr.Restore();
}
void GetMinPdsSize()
{
	int x=250,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+240, y+50, "최저 자료 크기 (KB단위)" );
	Scr.SetSaveOff();
	spGetMunja( x+10, y+29, MinPdsSize,"9999", "%-4s" );
	Scr.Restore();
}
void GetMinSpeed()
{
	int x=250,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+160, y+50, "최저 접속속도" );
	Scr.SetSaveOff();
	spmyGetMunja( x+10, y+29, MinSpeed, "BPS", "99999", "%-5s" );
	Scr.Restore();
}
void GetUsePartTime()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "파트타임 사용여부",
																			pMessage, pItem, UsePartTime);
	Scr.SetSaveOff();
	if ( flag != -1 ) UsePartTime = flag;
	Scr.Restore();
}
void GetEmulPro()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "통신 에뮬레이터 ( PATH까지 모두)" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, EmulPro,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
	_hangulmode=temp;
}
void GetEditPro()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "외부 에디터 ( PATH까지 모두)" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, EditPro,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
	_hangulmode=temp;
}
//----------------------------------------------------------------------
//                MENU  MAKE   PART
	 int no=0, MaxNo = 0;

void CutOffSpace(unsigned char *str)
{
	 int index=0;
	 for (index=strlen(str)-1; index>=0; index--)
		if ( str[index] == ' ') str[index]=0;
		else break;
}
void CopyString( char *cp1, char *cp2)
{
	while (*cp1++ = *cp2++);
}
int multi(int x1,int x2)
{
	 int tx1=x1;
	 if (x2==0) return 1;
	 while (x2-- > 1) x1 *=tx1;
	 return x1;
}
void LoadMenuOf10B()
{
	 int i,j,count;
	 char ch,number[7], tmpstr[10];
	 fstream  InFile("MENUDATA.DAT",ios::in);
	 if (!InFile) return;

	 count = -1; MaxNo=0;
	 while (InFile.get(ch), ch != '\n') number[++count] = ch;
	 for (j=0; j<=count; j++)
		 MaxNo += (number[j]-48)*multi(10, (count-j));

	 for (i=1; i<= MaxNo; i++)
	 {
		 count = -1; Menu[i].X = 0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].X += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].color =0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].color += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].head =0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].head += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].grade =0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].grade += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].close = 0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].close += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].run = 0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].run += (number[j]-48)*multi(10, (count-j));

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].index[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].title[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) tmpstr[++count]=ch;
		 tmpstr[++count] = 0;

		 Menu[i].type = 0;
		 if (!strcmp(tmpstr,"SUBMENU")) Menu[i].type = SUB;
		 if (!strcmp(tmpstr,"BBSMENU")) Menu[i].type = BBS;
		 if (!strcmp(tmpstr,"PDSMENU")) Menu[i].type = PDS;
		 if (!strcmp(tmpstr,"WMAIL")) Menu[i].type = WMAIL;
		 if (!strcmp(tmpstr,"RMAIL")) Menu[i].type = RMAIL;
		 if (!strcmp(tmpstr,"CHAT")) Menu[i].type = CHAT;
		 if (!strcmp(tmpstr,"JOIN")) Menu[i].type = JOIN;
		 if (!strcmp(tmpstr,"USERSEE")) Menu[i].type = VUSER;
		 if (!strcmp(tmpstr,"TIME")) Menu[i].type = TBANK;
		 if (!strcmp(tmpstr,"GROUP")) Menu[i].type = MSIG;
		 if (!strcmp(tmpstr,"NOTICE")) Menu[i].type = NOTICE;
		 if (!strcmp(tmpstr,"SCRIPT")) Menu[i].type = SCRIPT;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].go[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].ansifile[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].sysid[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) tmpstr[++count]=ch;
		 tmpstr[++count] = 0;
		 Menu[i].level = atoi(tmpstr);

		 count = -1;
		 while (InFile.get(ch), ch != FS) tmpstr[++count]=ch;
		 tmpstr[++count] = 0;
		 Menu[i].point = atoi(tmpstr);

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].pass[++count]=ch;

		 while (InFile.get(ch), ch != FS) Menu[i].f2= (ch=='1') ? 1 : 0;
		 while (InFile.get(ch), ch != FS) Menu[i].f3= (ch=='1') ? 1 : 0;
		 while (InFile.get(ch), ch != FS) Menu[i].f4= (ch=='1') ? 1 : 0;
		 while (InFile.get(ch), ch != FS) Menu[i].f5= (ch=='1') ? 1 : 0;
		 while (InFile.get(ch), ch != '\n') Menu[i].f6= (ch=='1') ? 1 : 0;
		 Menu[i].readlevel = 0;
		 Menu[i].writelevel = 0;
		 Menu[i].lowbirth = 0;
		 Menu[i].highbirth = 0;
		 Menu[i].bSecret =0;
	 }
	 InFile.close();
}

void SaveMenuFile()
{
	 int version;
	 int MenuNo;
	 FILE* mfile;

	 for(MenuNo=1; MenuNo<=MaxNo; MenuNo++)
	 {
			CutOffSpace( Menu[MenuNo].index);
			CutOffSpace( Menu[MenuNo].title);
			CutOffSpace( Menu[MenuNo].go);
			CutOffSpace( Menu[MenuNo].ansifile);
			CutOffSpace( Menu[MenuNo].sysid);
			CutOffSpace( Menu[MenuNo].pass);
	 }

	 version = IVER;
	 mfile = fopen("MENUDATA.DAT", "wb");
	 fwrite(&version, sizeof(version), 1, mfile);
	 fwrite(&MaxNo, sizeof(int), 1, mfile);
	 fwrite(&Menu[1], sizeof(struct menu_t), MaxNo, mfile);
	 fclose(mfile);
	 delay(2000); // wait for disk cash delay
	 system("copy mighty.cfg c:\\ > null");
}
void Convert10BMenuFile()
{
		  char *pWin[] = {
					 "  마이티 1.0B버젼의 메뉴화일을   ",
					 " 신버젼의 메뉴화일로 변환합니다. ",
					 "" };

	Scr.SetSaveOn();
		  spMessageWin( -1, -1, "메뉴화일 변환중", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();

		  LoadMenuOf10B();
		  SaveMenuFile();

		  delay(4000);
	Scr.Restore();
}

void LoadMenuFile()
{
	 int version;
	 FILE* mfile = fopen("MENUDATA.DAT", "rb");
	 if (mfile)
	 {
		  fread(&version, sizeof(version), 1, mfile);
		  if (version==IVER)
		  {
				fread(&MaxNo, sizeof(int), 1, mfile);
				fread(&Menu[1], sizeof(struct menu_t), MaxNo, mfile);
				fclose(mfile);
		  }
		  // insert any other version reading routine
		  else
		  {
				fclose(mfile);
				Convert10BMenuFile();
		  }
	 }
}

void MenuScreenInit()
{
	spBar3d1(0,0,639,62);
	spBar3d1(0,63,639,475);
	kmPuts(4,2,"#7@15마이티 호스트 ver 1.0 beta1.5  @13메뉴 편집기        @15 (@14C@15)@1 REFINED SOFTWARE ");
	kmPuts(4,3,"#7@10INSERT@15 : @9메뉴추가   @11DEL @15:@9 메뉴삭제   @12ENTER @15: @9메뉴편집  @14 화살표키 @15: 이동 ");
}
void TopMenuInit()
{

			 Menu[1].X = 1;
			 Menu[1].color = WYELLOW ;
			 Menu[1].run = 0;
			 Menu[1].type = SUB;
			 Menu[1].level =0;
			 Menu[1].point =0;
			 Menu[1].readlevel=0;
			 Menu[1].writelevel=0;
			 Menu[1].lowbirth=0;
			 Menu[1].highbirth=0;
			 Menu[1].bSecret = 0;
			 CopyString( Menu[1].index ,"000000");
			 CopyString( Menu[1].title ,"톱 메 뉴");
			 CopyString( Menu[1].go , "TOP");
			 Menu[1].grade = 0;
			 Menu[1].close = 0;
			 no++;
			 MaxNo++;

}

void InitMenu(int fr, int to)
{
		for (int i=fr; i <= to; i++) {
			 Menu[i].X = 0;
			 for (int j=0; j<6; j++) Menu[i].index[j] = '0';
			 Menu[i].index[6] = 0;
			 Menu[i].head = 0;
			 Menu[i].type = 0;
			 for (j=0; j< 21; j++) Menu[i].title[j] = 0;
			 for (j=0; j< 9; j++)
			 {
					 Menu[i].go[j] = 0;
					 Menu[i].ansifile[j] = 0;
					 Menu[i].sysid[j] = 0;
					 Menu[i].pass[j]=0;
			 }
			 Menu[i].level = 0;
			 Menu[i].point = 0;
			 Menu[i].readlevel=0;
			 Menu[i].writelevel=0;
			 Menu[i].lowbirth=0;
			 Menu[i].highbirth=0;
			 Menu[i].bSecret =0;
			 Menu[i].grade = 0;
			 Menu[i].close = 0;
			 Menu[i].color = 0;
			 Menu[i].run = 0;
			 Menu[i].f2 = 0;
			 Menu[i].f3 = 0;
			 Menu[i].f4 = 0;
			 Menu[i].f5 = 0;
			 Menu[i].f6 = 0;
		}

}

void BitFieldInit_Ins()
{
	 if (no<=2) return;
	 int m,i,j,k,flag=0;
	 k=no;
	 for ( i=2; i <= Menu[k].X -1; i++) {
			 for ( j=k; j <= MaxNo; j++)
			 {
					if (Menu[j].X == i ) flag=1;
					if (flag==1) break;
			 }
			 for (m = j; m >= k; m--) if (Menu[j].X > Menu[m].X) flag=0;
			 switch ( i ) {
				 case 2 : Menu[k].f2= flag?1:0;  break;
				 case 3 : Menu[k].f3= flag?1:0;  break;
				 case 4 : Menu[k].f4= flag?1:0;  break;
				 case 5 : Menu[k].f5= flag?1:0;  break;
				 case 6 : Menu[k].f6= flag?1:0;
			 }
			 flag=0;
		}
}
void BitFieldInit_Del()
{
	 if (no<=2) return;
	 int m,i,j,k,flag=0;
	 for ( j=no-1;j>=2;j--) if (Menu[no].X==Menu[j].X) break;
	 for (k=j; k<=no; k++) {
		 for ( i=2; i <= Menu[k].X -1; i++) {
			 for ( j=k; j <= MaxNo; j++)
			 {
					if (Menu[j].X == i ) flag=1;
					if (flag==1) break;
			 }
			 for (m = j; m >= k; m--) if (Menu[j].X > Menu[m].X) flag=0;
			 switch ( i ) {
				 case 2 : Menu[k].f2= flag?1:0;  break;
				 case 3 : Menu[k].f3= flag?1:0;  break;
				 case 4 : Menu[k].f4= flag?1:0;  break;
				 case 5 : Menu[k].f5= flag?1:0;  break;
				 case 6 : Menu[k].f6= flag?1:0;
			 }
			 flag=0;
		 }
	 }
}
void NotSavedOnHard()
{
	char *pWin[] = {
		" 하드 디스크에는 저장하지 ",
		" 않고 메모리에만  남겨 놓 ",
		" 았습니다.                ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "알려 드립니다", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}

void qSaveMenu()
{
	char far *pMessage[] = {
							 "   지금까지 작업한   ",
							 "   메뉴를   화일로   ",
							 "   저장하겠습니까?   ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"  예  ",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(310, 230,
							"저장하시겠습니까?", pMessage, pItem, 1);
	Scr.SetSaveOff();
	Scr.Restore();

	if ( flag == 1 ) SaveMenuFile();
	if ( flag == 0 ) NotSavedOnHard();

}

int ReallyEnd()
{
	char far *pMessage[] = {
							 " 메뉴 만들기를 그만 ",
							 " 하시겠습니까?      ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"  예  ",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1,
							"메뉴 만들기", pMessage, pItem, 0);
	Scr.SetSaveOff();
	if ( flag == 1 ) qSaveMenu();
	Scr.Restore();
	if ( flag != -1 ) return flag;

}
int ReallyDel()
{
	char far *pMessage[] = {
							 "                     ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"  예  ",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1,
							"정말 지우겠습니까?", pMessage, pItem, 0);
	Scr.SetSaveOff();
	Scr.Restore();
	if ( flag != -1 ) return flag;
	else return 0;
}


void ReadProtoFile()
{
	 int i;
	 FILE *fProto=fopen("PROTOCOL.DAT","rb");
	 if (fProto==NULL) return;
	 fseek(fProto,0L,SEEK_SET);
	 for (i=0; i<10; i++) fread(&Protocol[i],sizeof(Proto),1,fProto);
	 fclose( fProto );
}

void SaveProtoFile()
{
	 int i;
	 FILE *fProto=fopen("PROTOCOL.DAT","wb");
	 if (fProto==NULL) return;
	 fseek(fProto,0L,SEEK_SET);
	 for (i=0; i<10; i++)
	 {
		  CutOffSpace(Protocol[i].Exec);
		  CutOffSpace(Protocol[i].Up);
		  CutOffSpace(Protocol[i].Dn);
		  fwrite(&Protocol[i],sizeof(Proto),1,fProto);
	 }
	 fclose( fProto );
}

void SaveProto()
{
	char far *pMessage[] = {
							 "   지금까지 작업한   ",
							 "   프로토콜 화일을   ",
							 "   저장하겠습니까?   ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"  예  ",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(390, 170,
							"저장하시겠습니까?", pMessage, pItem, 1);
	Scr.SetSaveOff();
	Scr.Restore();

	if ( flag == 1 ) SaveProtoFile();
	if ( flag == 0 ) NotSavedOnHard();

}
/*
bool IsSameRunNum()
{
	hgotoxy(10,25); hprintf("max num--> %d",MaxNo);
	getch();
	//spWait();
	if ( MaxNo <= 2 ) return false;
	int i,fr,to;
	i = no;
	while ( Menu[i--].X == Menu[no].X );  fr = i ;
	i = fr;
	while ( Menu[i++].X == Menu[no].X );  to = i ;
	hgotoxy(60,25); hprintf("from %d to %d",fr,to);
	getch();
	//spWait();
	for (i=fr; i<=to; i++)
		 if ( Menu[no].RunNo == Menu[i].RunNo)
			 if (no != i) return true;
	return false;
}

void SameRunNum()
{
	char *pWin[] = {
		" 지금 입력하신 키는 이미 입력 ",
		" 된 키 입니다. 다른키를 눌러  ",
		" 주시기 바랍니다.             ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	getch();
	//spWait();
	Scr.Restore();
}
*/
int	GetMenuRunNum()
{
	char RunNo[3];
	int x=220, y=215, ReadKey, ret=0;
	Scr.SetSaveOn();
	spBoxWin( x, y, x+244, y+50, "메뉴실행번호( 1 ~ 35 )" );
	Scr.SetSaveOff();
	if (Menu[no].run == 0) strcpy(RunNo,"  ");
	else itoa(Menu[no].run, RunNo, 10);
	while( !ret || ReadKey < 1 || ReadKey > 35 )
	{
		ret = spGetMunja( x+108, y+29, RunNo, "99", "%-2s" );
		ReadKey = atoi(RunNo);
	}

	Scr.Restore();

	/*if ( same = IsSameRunNum() ) SameRunNum();*/
	return ReadKey;
}
void OutOfMenuMax()
{
	char *pWin[] = {
		" 현재 메뉴수가 사용 가능한  ",
		" 한계를 넘어 섰습니다.      ",
		" 다른 메뉴를 삭제한 후 메뉴 ",
		" 를 추가 하십시오.          ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();

}

void OutOfX()
{
	char *pWin[] = {
		" 톱메뉴 하위에 존재할 수 ",
		" 있는 메뉴수의 범위를 벗 ",
		" 어났습니다.             ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}

void CanNotDel1()
{
	char *pWin[] = {
		" 현재 지우려고 하는 메뉴는 ",
		" 서브메뉴이므로 지울 수 없 ",
		" 습니다. 먼저 하위 메뉴를  ",
		" 지우시기 바랍니다.        ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}

void CanNotDel2()
{
	char *pWin[] = {
		" 현재 지우려고 하는 메뉴는  ",
		" 톱메뉴 이므로 지울수 없습  ",
		" 니다.                      ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();

}

void NotPrepared()
{
	char *pWin[] = {
                " 선택하신 메뉴 형식은 아직 ",
                " 지원하지 않는 메뉴입니다. ",
                " 다음 버젼인 1.0정식버젼   ",
					 " 에서 지원합니다.          ",
		"" };

	Scr.SetSaveOn();
	spMessageWin( -1, -1, "죄송합니다", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}

void GetMenuType(void)
{
		int Color[19] = { WYELLOW,    // SUB
								CYAN,       // BBS
								WLIGHTBLUE, // PDS
								WDARKGREEN, // OMAIL
								WDARKGREEN, // WMAIL
								WDARKGREEN, // RMAIL
								WDARKGREEN, // MBOX
								WMAGENTA  , // CHAT
								WLIGHTRED,  // JOIN
								WLIGHTRED,  // VUSER
								WLIGHTRED,  // EDITSELF
								3,          // TBANK
								WDARKBLUE,  // MSIG
								WDARKRED,   // NOTICE
								WLIGHTGREEN, // SCRIPT
								WLIGHTBLUE, // CDROMPDS
								WLIGHTBLUE, // RDNPDS
								WLIGHTBLUE, // PDSSEARCH
								WDARKGREEN // MSEE

								};

			char far *pMenu[20] = {
											"   서브  메뉴   ",
											"   게  시  판   ",
											"   자  료  실   ",
											"   공개  편지   ",
											"   편지  읽기   ",
											"   편지  쓰기   ",
											"   편지보관함   ",
											"   대  화  실   ",
											"   가입  메뉴   ",
											"   회원  검색   ",
											"  자기정보관리  ",
											"   시간  은행   ",
											"   동호회관리   ",
											"   공지  사항   ",
											"   스크  립트   ",
											"  CD-ROM자료실  ",
											"   RDN 자료실   ",
											" 담당자수신편지 ",
											"  보낸편지확인  ",
											""};


	Scr.SetSaveOn();
	int flag=spPopUpWin( 100, -1, 19, "메뉴 종류", pMenu, 0);
	Scr.SetSaveOff();
	Scr.Restore();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) )
	{
		switch(flag+1)
		{
			case RDNPDS:
			case EDITSELF:
				  NotPrepared();
				  break;
			default:
				  Menu[no].type = flag+1; // definition starts from 1
				  Menu[no].color = Color[flag];
		}
	}
}
int isExistGoOrder()
{
	int bExist=0, MenuItem;
	for(MenuItem=1; MenuItem<=MaxNo; MenuItem++)
	{
		 if (MenuItem != no)
		 {
			  CutOffSpace(Menu[no].go);
			  CutOffSpace(Menu[MenuItem].go);
			  if ( !stricmp(Menu[no].go, Menu[MenuItem].go) )
			  {
				  bExist=1;
				  break;
			  }
		 }

	}
	return bExist;
}
void GoOrderExist()
{
	char *pWin[] = {
					 "  이미 다른 메뉴에서 사용한  ",
					 "  GO 행선지입니다.  다른 행  ",
					 "  선지를 입력하세요.         ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}
void GetGoOrder()
{
	int x=263,y=200;
	int bExistGo=0, flag;
	char PreviousGoOrder[9];
	bool temp = _hangulmode;
	_hangulmode = false;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+114, y+50, "GO 행선지" );
	Scr.SetSaveOff();

	strcpy(PreviousGoOrder, Menu[no].go);
	do
	{
		 flag=spGetMunja( x+10, y+29, Menu[no].go, "XXXXXXXX", "%-8s" );
		 if (flag==27)
		 {
			  strcpy(Menu[no].go, PreviousGoOrder);
			  break;
		 }
		 else if (bExistGo=isExistGoOrder()) GoOrderExist();
	} while(bExistGo);
	Scr.Restore();
	_hangulmode = temp;
}
void GetSysId()
{
	int x=200,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+140, y+50, "담당 아이디" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, Menu[no].sysid, "XXXXXXXX", "%-8s" );
	Scr.Restore();
}

int GetPass()
{
	int x=215,y=200,flag;
	bool temp = _hangulmode;
	_hangulmode = false;

	Scr.SetSaveOn();
	flag = spBoxWin( x, y, x+122, y+50, "사용 암호" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, Menu[no].pass, "XXXXXXXX", "%-8s" );
	Scr.Restore();
	_hangulmode = temp;
	if (flag==0) return -1;
}
void CopyFailed()
{
	char *pWin[] = {
													  "  안시화일을 복사하는데  ",
                                         "  실패하였습니다.  DOS   ",
													  "  에러 입니다.           ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}

void CopySuccess()
{
	char *pWin[] = {
							"  안시화일을 복사하는데  ",
							"  성공하였습니다.        ",
							"" };

	Scr.SetSaveOn();
					 spMessageWin( -1, -1, "복사 성공", pWin, WWHITE, WLIGHTBLUE);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}
int WantCopy()
{
	char far *pMessage[] = {
									  "   선택한 화일은 안시 디렉토리에   ",
									  "   존재하여야 합니다. 안시화일을   ",
									  "   안시 디렉토리로  복사하시겠습   ",
									  "   니까? 같은 이름의 화일이 있을   ",
									  "   경우 원래 화일에 덮어씁니다.    ",
									  ""};
	char far *pItem[] = {
								"아니오",
								"  예  ",
								""};

	Scr.SetSaveOn();
		  int flag = spChoiceItemWin( -1, -1,"복사 하시겠습니까?", pMessage, pItem, 1);
	Scr.SetSaveOff();
	Scr.Restore();
	if (flag==-1) return 0;
	else return flag;
}
// cut the extension of file name.
void CutExtName(char* fname)
{
	  int i;
	  for (i=strlen(fname)-1; i>=0; i--)
			if (fname[i]=='.')
			{
				 fname[i]=NULL;
				 break;
			}
}
void GetAnsiFile()
{
	int x=120,y=80;
	char fname[13];
	char path[200];
	long fsize;
	CFileSelector* FBox=new CFileSelector(x, y, WLIGHTGRAY, WDARKBLUE, 5);

	Scr.SetSaveOn();
	spBoxWin( x-5, y-25, FBox->maxx()+5, FBox->maxy()+5, "안시/스크립트 화일 이름" );
	Scr.SetSaveOff();

	int ret = FBox->SelectFile( path, fname, fsize);
	if (ret != CANCEL)
	{
		 if (AnsiDir[strlen(AnsiDir)-1]=='\\') AnsiDir[strlen(AnsiDir)-1]=NULL;
		 path[strlen(path)-1]=0;  // remove last char '\\'
		 if (!stricmp(AnsiDir, path)) // the file in AnsiDir ?
		 {
			  CutExtName(fname);
			  strcpy(Menu[no].ansifile, fname);
		 }
		 else
		 {
			  if (WantCopy()) // do you want to copy it?
			  {
					char doscmd[200];
					sprintf(doscmd, "copy /y %s\\%s %s\\%s >null",path, fname, AnsiDir, fname);
					if (system(doscmd)==0)  // success??
					{
						 CutExtName(fname);
						 strcpy(Menu[no].ansifile, fname);
						 CopySuccess();
					}
					else CopyFailed();
			  }
		 }
	}
	delete FBox;
	//spGetMunja( x+10, y+29, Menu[no].ansifile, "XXXXXXXX", "%-8s" );
	Scr.Restore();
}
void GetPoint()
{
	int x=230,y=200;
	char point[10];
	Scr.SetSaveOn();
	spBoxWin( x, y, x+180, y+50, "활동시 얻는 점수" );
	Scr.SetSaveOff();

	itoa(Menu[no].point, point, 10);
		  spGetMunja( x+10, y+29, point, "9999", "%-4s" );
	Menu[no].point = atoi(point);

	Scr.Restore();
}

void GetLevel()
{
	int x=225,y=200;
	char level[10];
	Scr.SetSaveOn();
	spBoxWin( x, y, x+190, y+50, "사용 가능한 레벨" );
	Scr.SetSaveOff();

	itoa(Menu[no].level, level, 10);
		  spGetMunja( x+10, y+29, level, "9999", "%-4s" );
	Menu[no].level = atoi(level);

	Scr.Restore();
}

void GetGrade()
{
	char far *pItem[] = {
																					 "   사용중지,손님(동호회) ",
																					 "         비 회 원        ",
																					 "         회 원  3        ",
																					 "         회 원  2        ",
																					 "         회 원  1        ",
																					 "         정 회 원        ",
																					 "         부운영자        ",
																					 "         운 영 자        ",
																					 ""};

	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 8, "사용 가능 등급", pItem, Menu[no].grade);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) Menu[no].grade=flag;
	Scr.Restore();
}
void GetWriteLevel()
{
		  int x=100,y=200;
	char level[10];
	Scr.SetSaveOn();
		  spBoxWin( x, y, x+460, y+50, "글쓰기/업로드 가능한 레벨 (레벨 0 : 누구나 가능)" );
	Scr.SetSaveOff();

		  itoa(Menu[no].writelevel, level, 10);
		  spGetMunja( x+200, y+29, level, "9999", "%-4s" );
		  Menu[no].writelevel = atoi(level);

	Scr.Restore();
}

void GetReadLevel()
{
		  int x=100,y=200;
	char level[10];
	Scr.SetSaveOn();
		  spBoxWin( x, y, x+460, y+50, "글읽기/다운로드 가능한 레벨 (레벨 0: 누구나 가능)" );
	Scr.SetSaveOff();

		  itoa(Menu[no].readlevel, level, 10);
		  spGetMunja( x+200, y+29, level, "9999", "%-4s" );
		  Menu[no].readlevel = atoi(level);

	Scr.Restore();
}
void GetLowBirth()
{
		  int x=120,y=200;
		  char birth[3];
	Scr.SetSaveOn();
		  spBoxWin( x, y, x+420, y+50, "??년 이후 출생자 출입가능( 00년 : 제한 안함 )" );
	Scr.SetSaveOff();

		  itoa(Menu[no].lowbirth, birth, 10);
		  spmyGetMunja( x+200, y+29, birth, "년", "99", "%-2s" );
		  Menu[no].lowbirth = atoi(birth);

	Scr.Restore();
}
void GetHighBirth()
{
		  int x=120,y=200;
		  char birth[3];
	Scr.SetSaveOn();
		 spBoxWin( x, y, x+420, y+50, "??년 이전 출생자 출입가능( 00년 : 제한 안함 )" );
	Scr.SetSaveOff();

		  itoa(Menu[no].highbirth, birth, 10);
		  spmyGetMunja( x+200, y+29, birth, "년","99", "%-2s" );
		  Menu[no].highbirth = atoi(birth);

	Scr.Restore();
}




void GetClose()
{
	int mode =1;
	char far *pMessage[] = {
							 " 이 메뉴를 공개할 것인지 아니면 ",
							 " 비공개로 운영할 것인지  결정하 ",
							 " 여 주십시오.                   ",
							 ""};
	char far *pItem[] = {
								" 공개 ",
								"비공개",
								""};

PrintGetClose :
	if ( mode == 1 ) Scr.SetSaveOn();
        int flag = spChoiceItemWin(-1, -1, "공개 / 비공개", pMessage, pItem, Menu[no].close);
	if ( mode == 1 ) Scr.SetSaveOff();
	mode = 0;

	if ( flag != -1 ) Menu[no].grade = flag;
	if ( flag == 1 )
		if ( GetPass() == -1 ) goto PrintGetClose;
		else
		{
			Scr.Restore();
			Menu[no].close = flag;
			return;
		}
	Menu[no].close = flag;
	Scr.Restore();
}
void GetSecret()
{
	char far *pMessage[] = {
							 " 이 메뉴에 자료를 제공한 사람의  ",
							 " 아이디를 공개할 것인지 공개하지 ",
							 " 않을것인지 결정하십시오.        ",
							 ""};
	char far *pItem[] = {
								" 공개 ",
								"비공개",
								""};

		  Scr.SetSaveOn();
		  int flag = spChoiceItemWin(-1, -1, "공개 / 비공개", pMessage, pItem, Menu[no].bSecret);
		  Scr.SetSaveOff();

		  if ( flag != -1 )
				if (flag) Menu[no].bSecret = 1;
				else Menu[no].bSecret = 0;
		  Scr.Restore();
}
void AutoWrite()
{
	int x=120,y=80, ret;
	char fname[13];
	char path[200];
	long fsize;
	CFileSelector* FBox=new CFileSelector(x, y, WLIGHTGRAY, WDARKBLUE, 5);

	Scr.SetSaveOn();
		  spBoxWin( x-5, y-25, FBox->maxx()+5, FBox->maxy()+5, "등록할 화일을 고르세요" );
	Scr.SetSaveOff();

	// end of path is '\\'
	ret = FBox->SelectFile( path, fname, fsize);
	delete FBox;
	CutOffSpace(InstDir);
	char doscmd[200];
	while(ret != CANCEL)
	{
		 switch( Menu[no].type )
		 {
			 case PDS:
			 case CDROMPDS:
				 sprintf(doscmd, "autoup %s%s %s\\%s > null",path, fname, InstDir, Menu[no].index);
				 break;
			 case OMAIL:
			 case NOTICE:
			 case BBS:
				 sprintf(doscmd, "autowrt %s%s %s\\%s > null",path, fname, InstDir, Menu[no].index);
				 break;
		 }
		 system(doscmd);

		 FBox=new CFileSelector(x, y, WLIGHTGRAY, WDARKBLUE, 5);
		 ret = FBox->SelectFile( path, fname, fsize);
		 delete FBox;
	}
	//spGetMunja( x+10, y+29, Menu[no].ansifile, "XXXXXXXX", "%-8s" );
	Scr.Restore();
}

void PrintBar(int num, int c)
{

	 int tempbkcolor,tempcolor;
	 int Mx = SMX + (Menu[num].X - 1) * GABX;
	 int My = SMY + (num % MLINES);
		 if (num % MLINES == 0) My += MLINES;
	 tempbkcolor = hgetbkcolor();
	 tempcolor = hgetcolor();
	 hsetbkcolor(c);
	 hgotoxy (Mx,My);
	 hputs("                    ");
	 hgotoxy (Mx,My);
	 if (c==MBC) {
			 hsetcolor(WBLACK);
			 if (Menu[num].run != 0)
					hprintf( "[%i]",Menu[num].run );
	 }
	 else
	 {
			 if (Menu[num].run != 0)
					{
						hsetcolor( WWHITE );  hputs("[");
						hsetcolor( WLIGHTBLUE ); hprintf( "%i",Menu[num].run );
						hsetcolor( WWHITE );  hputs("]");
					}
			 hsetcolor(Menu[num].color);
	 }
	 hputs(Menu[num].title);
	 hsetbkcolor(MBKC);
	 hsetcolor(WLIGHTBLUE);
	 hgotoxy(65,6);
	 hputs("인덱스번호");
	 hgotoxy(69,7);
	 hputs(Menu[no].index);
	 hsetcolor(WBLACK);
	 hsetbkcolor(MBC);

	 if (Menu[num].f2 )
			rectangle( (SMX+GABX) *8 -17 , (My-1)*16, (SMX+GABX) *8 -16 , My*16-1 );
	 if (Menu[num].f3 )
			rectangle( (SMX+2*GABX) *8 -17 , (My-1)*16, (SMX+2*GABX) *8 -16 , My*16-1 );
	 if (Menu[num].f4 )
			rectangle( (SMX+3*GABX) *8 -17 , (My-1)*16, (SMX+3*GABX) *8 -16 , My*16-1 );
	 if (Menu[num].f5 )
			rectangle( (SMX+4*GABX) *8 -17 , (My-1)*16, (SMX+4*GABX) *8 -16 , My*16-1 );
	 if (Menu[num].f6 )
			rectangle( (SMX+5*GABX) *8 -17 , (My-1)*16, (SMX+5*GABX) *8 -16 , My*16-1 );

	 switch (Menu[num].head) {
		 case 0 : break;
		 case 1 : rectangle(Mx*8-17,(My-1)*16,Mx*8-16,My*16-1);
							line(Mx*8-16,My*16-8,Mx*8+7-16,My*16-8);
							break;

		 case 2 : rectangle(Mx*8-17,(My-1)*16,Mx*8-16,My*16-8);
							line(Mx*8-16,My*16-8,Mx*8+7-16,My*16-8);

							break;
	 }
	 hsetbkcolor(tempbkcolor);
	 hsetcolor(tempcolor);


}
void CanNotGetRunNo()
{
	char *pWin[] = {
		" 톱메뉴의 메뉴실행번호는 ",
		" 바꿀 수 없습니다",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "알려 드립니다", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}
void PrintMenu( int start )
{

	 int end;
	 if (MaxNo == 0) return;
	 if (MaxNo - start < MLINES ) end = MaxNo;
	 else end = start + MLINES -1 ;

	 spFill( 10, 73, 620, 465 , WLIGHTGRAY);
	 for (int i = start; i <= end ;i++ ) PrintBar(i,MBKC);
}

void GetRunNo()
{
	 int i;
	 if ( no==1 )
	 {
		  CanNotGetRunNo();
		  return;
	 }
	 Menu[no].run = GetMenuRunNum();

	 if (no > 2)

	 for (i=2; i<  Menu[no].X ; i++)
	 {
		 for (int j=no-1; j>=2; j-- )
		 {
				if ( i == Menu[j].X )
					 if ( Menu[no].index[i-2] == '0')
					 {
						  if (Menu[j].run <= 9 )
							 Menu[no].index[i-2] = Menu[j].run + '0';
						  else  Menu[no].index[i-2] = Menu[j].run - 10 + 'A';
					 }
		 }
	 }

	 if (Menu[no].run <= 9 )
		 Menu[no].index[Menu[no].X -2] = Menu[no].run + '0';
	 else  Menu[no].index[Menu[no].X -2] = Menu[no].run - 10 + 'A';

	 int diff;
	 if ( no%MLINES==0 ) diff = MLINES;
	 else diff = no%MLINES;

	 char doscmd[200];
	 CutOffSpace(InstDir);
	 sprintf(doscmd, "%s\\%s", InstDir, Menu[no].index);
	 mkdir(doscmd);

	 PrintMenu( no - diff + 1 );
	 PrintBar( no, MBC);
}
int GetTitle(int mode=0)
{
	int x=233,y=200,flag=0;
	char temp[21];

	hsetcolor(WBLACK);
	Scr.SetSaveOn();
	spBoxWin( x, y, x+182, y+50, "메뉴의 제목" );
	Scr.SetSaveOff();
	if (mode) {
		 CopyString(temp,Menu[no].title);
		 for (int i=0; i<=20; i++) Menu[no].title[i]=0;
	}
	flag = spGetMunja( x+10, y+29, Menu[no].title,
													"XXXXXXXXXXXXXXXXXXXX", "%-20s" );
	if (mode && (flag==27)) CopyString(Menu[no].title,temp);
	Scr.Restore();
	hsetcolor(WWHITE);
	return flag;
}


void InsMenu()
{
	 char NewTitle[21],OriTitle[21];
	 if ( MaxNo >= MAXMENU ) { OutOfMenuMax(); return; }
	 if ( Menu[no].X == MAXX ) { OutOfX(); return; }
	 no++;
	 MaxNo++;

	 CopyString ( OriTitle, Menu[no].title);
	 if (  GetTitle(1) == 27 ) {
			no--;
			MaxNo--;
			return;
	 }
	 else {
				 CopyString (NewTitle, Menu[no].title);
				 CopyString (Menu[no].title, OriTitle);
				}
	 for (int i = MaxNo-1 ; i >= no ; i--) Menu[i+1]=Menu[i];
	 InitMenu(no, no);
	 CopyString (Menu[no].title,NewTitle);

	 Menu[no].X = Menu[no-1].X + 1;
	 if ( Menu[no].X == Menu[no+1].X ) Menu[no].head = 1;
	 else Menu[no].head = 2;

	 GetRunNo();

	 BitFieldInit_Ins();
	 PrintMenu( (no / MLINES) * MLINES + 1 );
	 PrintBar(no,MBC);
	 EditMenu();
}

void DelMenu()
{
	 if ( no < 1 ) return;
	 int temp,toModify;
	 int flag=0;
	 if (no == 1) {
			CanNotDel2();
			return;
	 }
	 if (no < MaxNo)
				if (Menu[no].X < Menu[no+1].X) {
				 CanNotDel1();
				 return;
			}

	 if (ReallyDel() != 1) return;

	 for (int i=no-1; i >= 1; i--) {
		 if (Menu[no].X == Menu[i].X) {
			 flag=1;
			 toModify=i;
			 break;
		 }
	 }
	 if (flag) for (i=toModify + 1; i < no; i++) if (Menu[i].X <Menu[no].X) flag=0;
	 if (flag)
	 {
		 flag=0;
		 for (i=no+1; i <= MaxNo; i++) {
			if (Menu[no].X == Menu[i].X) {
				flag=1;
				temp=i;
				break;
			}
		 }
		 if (flag) for (i=no + 1; i < temp; i++) if (Menu[i].X <Menu[no].X) flag=0;
		 if (flag) Menu[toModify].head = 1;
		 else Menu[toModify].head = 2;
	 }
	 for (i=no;i <= MaxNo; i++) Menu[i]=Menu[i+1];
	 InitMenu (MaxNo,MaxNo);
	 MaxNo--;
	 no--;

	 BitFieldInit_Del();
	 if (no % MLINES == 0)
			PrintMenu( ( no / MLINES - 1)* MLINES + 1);
	 else PrintMenu( (no / MLINES)* MLINES + 1);
	 PrintBar(no,MBC);
}
void EditMenu()
{
		class PopUp_  MenuMaking;
		int choonum,flag,mode=1;
		char far *pMenu[20] = {
					 "  메뉴 실행 번호  ",
					 "  메  뉴  이  름  ",
					 "  메  뉴  종  류  ",
					 "  Go 행선지 단어  ",
					 "  안  시  화  일  ",
					 "  활 동 시 점 수  ",
					 "LINE",
					 "  사용 가능 레벨  ",
					 "  사용 가능 등급  ",
					 "  읽기 가능 레벨  ",
					 "  쓰기 가능 레벨  ",
					 "  ??년 이후 가능  ",
					 "  ??년 이전 가능  ",
					 "LINE",
					 "  담 당 아 이 디  ",
					 "  공  개  여  부  ",
					 "  아 이 디 공 개  ",
					 "LINE",
					 "  자  동  등  록  ",
					 ""};


						int PopMenuState[2][20][20] =
					{
						{
							{ 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0 }, // UNDEFINED
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // SUBMENU
							{ 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1,-1, 1, 0 }, // BBSMENU
							{ 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1,-1, 1, 0 }, // PDSMENU
							{ 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1,-1, 1, 0 }, // OPENMAIL
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // READMAIL
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // WRITEMAIL
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1, 1, 1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // MBOX
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // CHAT MENU
							{ 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // JOIN IN MENU
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // VIEW USER
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // SELF INFO
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // TIME BANK
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1, 1, 1,-1,-1,-1, 0 }, // MSIG
							{ 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1,-1, 1, 0 }, // NOTICE
							{ 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // SCRIPT
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1, 1,-1, 1, 1,-1, 1, 1, 1,-1, 1, 0 }, // CD-ROM PDS
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1, 1,-1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }, // RDN PDS
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1, 1, 1,-1, 1, 1,-1,-1,-1, 0 }, // SEND MAIL
							{ 1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1,-1,-1, 0 }  // MSEE
						},
						{
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // UNDEFINED
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // SUBMENU
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1, 1, 0 }, // BBSMENU
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1, 1, 0 }, // PDSMENU
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1, 1, 0 }, // OPENMAIL
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // READMAIL
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // WRITEMAIL
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // MBOX
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // CHAT MENU
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // JOIN IN MENU
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // VIEW USER
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // SELF INFO
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // TIME BANK
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // MSIG
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1, 1, 0 }, // NOTICE
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // SCRIPT
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1, 1, 0 }, // CD-ROM PDS
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // RDN PDS
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }, // SEND MAIL
						  { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 1,-1,-1, 0 }  // MSEE
						}
					};
		if (mode ) Scr.SetSaveOn();
			  spWin( 305, 123, 543, 405, "");
		if (mode ) Scr.SetSaveOff();

PrintEditMenu :

	char Close[21];
	char    *Grade[] = {
								"[사용중지][손님(동호회)]",
								"[비회원]",
								"[회원3]",
								"[회원2]",
								"[회원1]",
								"[정회원]",
								"[부운영자]",
								"[운영자]",
								""};
		switch (Menu[no].close) {
			case 0 : CopyString(Close,"[공개]");  break;
			case 1 : CopyString(Close,"[비공개] / ");
						CopyString(Close+11, Menu[no].pass);
						break;
			default : CopyString(Close+11, "   ");
		}
						spBoxFill( 305, 123, 543, 405 , WLIGHTBLUE);
						spBoxLine( 305, 123, 543, 231 , WWHITE,WDARKBLUE);
						spBoxLine( 305, 232, 543, 343 , WWHITE,WDARKBLUE);
						spBoxLine( 305, 344, 543, 405 , WWHITE,WDARKBLUE);

				 hsetbkcolor (WLIGHTBLUE);
				 hsetcolor (WWHITE);

		int type = Menu[no].type;
		if (PopMenuState[st][type][0]>0) {hgotoxy(40,9); hprintf("%2i",Menu[no].run);}
		if (PopMenuState[st][type][1]>0) {hgotoxy(40,10); hputs(Menu[no].title); }
		if (PopMenuState[st][type][2]>0) {hgotoxy(40,11); hputs(MNAME[ Menu[no].type ]);}
		if (PopMenuState[st][type][3]>0) {hgotoxy(40,12); hputs(Menu[no].go); }
		if (PopMenuState[st][type][4]>0) {hgotoxy(40,13); hputs(Menu[no].ansifile); }
		if (PopMenuState[st][type][5]>0) {hgotoxy(40,14); hprintf("%i (점)", Menu[no].point); }
		if (PopMenuState[st][type][7]>0) {hgotoxy(40,16); hprintf("%i", Menu[no].level);}
		if (PopMenuState[st][type][8]>0) {hgotoxy(40,17); hputs(Grade[Menu[no].grade]);}
		if (PopMenuState[st][type][9]>0)
		{
			 hgotoxy(40,18);
			 if (Menu[no].readlevel) hprintf("레벨 %i이상 읽기/다운 가능",Menu[no].readlevel);
				 else hputs("아무나 가능");
		}
		if (PopMenuState[st][type][10]>0)
		{
			 hgotoxy(40,19);
			 if (Menu[no].writelevel) hprintf("레벨 %i이상 쓰기/업 가능",Menu[no].writelevel);
				  else hputs("아무나 가능");
		}
		if (PopMenuState[st][type][11]>0)
		{
			 hgotoxy(40,20);
			 if (Menu[no].lowbirth) hprintf("%i년 이후 출생자만 통과", Menu[no].lowbirth);
				  else hputs("제한하지 않음");
		}
		if (PopMenuState[st][type][12]>0)
		{
			 hgotoxy(40,21);
			 if (Menu[no].highbirth) hprintf("%i년 이전 출생자만 통과", Menu[no].highbirth);
				 else hputs("제한하지 않음");
		}
		if (PopMenuState[st][type][14]>0)
		{
			 hgotoxy(40,23);
			 CutOffSpace(Menu[no].sysid);
			 if (Menu[no].sysid[0]!=0) hputs(Menu[no].sysid);
				 else hputs("[담당자 없음]");
		}
		if (PopMenuState[st][type][15]>0) { hgotoxy(40,24); hputs(Close); }
					 if (PopMenuState[st][type][16]>0)
					 {
							  hgotoxy(40,25);
							  if (Menu[no].bSecret) hputs("[아이디 비공개]");
							  else hputs("[아이디 공개]");
					 }
				 hsetbkcolor (MBKC);
		if (mode) Scr.SetSaveOn();
				 MenuMaking.PopUp( 150, 123, WWHITE, WBLACK, pMenu, PopMenuState[st][Menu[no].type]);
		if (mode) Scr.SetSaveOff();
		mode = 0;

		// Warning! Never change about MenuMaking instance.
		// I made a new function SetState.
		// MenuMaking.PopUp( 150, 123, WWHITE, WBLACK, pMenu, PopMenuState[st][Menu[no].type]);
		MenuMaking.SetState(PopMenuState[st][Menu[no].type]);
		MenuMaking.PopUp( 150, 123, WWHITE, WBLACK, pMenu, PopMenuState[st][Menu[no].type]);

		flag = MenuMaking.PopUpSelect();

		if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) choonum = flag;
		else  {
						Scr.Restore();
						Scr.Restore();
						PrintBar(no,MBC);
						return;
					}
		switch (choonum) {
			case 0 : GetRunNo();   break;
			case 1 : GetTitle() ;   break;
			case 2 : GetMenuType() ;   break;
			case 3 : GetGoOrder() ;  break;
			case 4 : GetAnsiFile() ;  break;
			case 5 : GetPoint() ;  break;
			case 7 : GetLevel() ;  break;
			case 8 : GetGrade() ;  break;
			case 9 : GetReadLevel(); break;
			case 10: GetWriteLevel(); break;
			case 11: GetLowBirth(); break;
			case 12: GetHighBirth(); break;
			case 14: GetSysId();  break;
			case 15: GetClose();  break;
			case 16: GetSecret(); break;
			case 18: AutoWrite(); break;
					 }
		goto PrintEditMenu;
}





void UpArr()
{
	if ( no <= 1 ) return;
	no--;

	if ( (( no % MLINES ) == 0 ) && ( no >= MLINES ) )  {
		 PrintMenu( no - MLINES + 1 );
		 PrintBar( no, MBC);
	}
	else {
				PrintBar(no+1,MBKC);
				PrintBar(no,MBC);
			 }
}
void DnArr()
{
	if ( no >= MaxNo )  return;
	no++;

	if ( ((no -1) % MLINES ) == 0 ) {
		 PrintMenu( no );
		 PrintBar( no, MBC);
	}
	else {
				PrintBar(no-1,MBKC);
				PrintBar(no,MBC);
			 }

}

int count=0;

void MenuMake()
{
	char ch;

	MenuScreenInit();
	setcolor(NCDLINECOLOR);
	if (count++==0) {
		InitMenu(0,MAXMENU);
		TopMenuInit();
		LoadMenuFile();
	}
	PrintMenu(1);
	no=1;
	PrintBar(no,MBC);
	int endroutine = 0;
	while ( endroutine == 0 )
		if ( bioskey(1) != 0 ) {
			ch=getch();
			switch(ch) {
				case 0 :
							ch = getch();
							switch(ch) {
								case 82 : InsMenu(); break;
								case 83 : DelMenu(); break;
								case 72 : UpArr();  break;
								case 80 : DnArr();
							}
							break;
				case 13 :  EditMenu();  break;
				case 27 :  if ( ReallyEnd() ) endroutine = 1;
			}
		}
	ScreenInit();
}

void ProtoMake()
{
	int mode = 1;
	char far *pMenu[11] = {
				 "   1 번 프로토콜   ",
				 "   2 번 프로토콜   ",
				 "   3 번 프로토콜   ",
				 "   4 번 프로토콜   ",
				 "   5 번 프로토콜   ",
				 "   6 번 프로토콜   ",
				 "   7 번 프로토콜   ",
				 "   8 번 프로토콜   ",
				 "   9 번 프로토콜   ",
				 "   10번 프로토콜   ",
				 ""};

ProtoMenu :

	if ( mode == 1 ) Scr.SetSaveOn();
	int flag=spPopUpWin( 450, 80, 10, "    프로토콜 편집기    ", pMenu, 0);
	if ( mode == 1 ) Scr.SetSaveOff();

	mode = 0;

	if ( flag == -1 ) {
		 SaveProto();
		 Scr.Restore();
		 return;
	}
	else ProtoEditBox(flag);
	goto ProtoMenu;

}
void ProtoEditBox(int Index)
{
	char *Title;
	struct EditBox_ far *EBox;
	if( !(EBox = new EditBox_[4]) ) return;

	char far *FieldTitles[] =
	{
		"실행화일 이름",
		"업 로 드 옵션",
		"다운로드 옵션",
		"종료",
		""
	};

	switch (Index) {
		case 0 : Title = "1 번 프로토콜 편집"; break;
		case 1 : Title = "2 번 프로토콜 편집"; break;
		case 2 : Title = "3 번 프로토콜 편집"; break;
		case 3 : Title = "4 번 프로토콜 편집"; break;
		case 4 : Title = "5 번 프로토콜 편집"; break;
		case 5 : Title = "6 번 프로토콜 편집"; break;
		case 6 : Title = "7 번 프로토콜 편집"; break;
		case 7 : Title = "8 번 프로토콜 편집"; break;
		case 8 : Title = "9 번 프로토콜 편집"; break;
		case 9 : Title = "10번 프로토콜 편집";
	}
	EditProto( EBox, Index, 0, 0);

	Scr.SetSaveOn();
	spTitleEditBoxWin( 100, 170,
				 Title, FieldTitles, EBox);
	Scr.SetSaveOff();

	Scr.Restore();

	CopyString(Protocol[Index].Exec, EBox[0].munja);
	CopyString(Protocol[Index].Up, EBox[1].munja);
	CopyString(Protocol[Index].Dn, EBox[2].munja);

	delete[] EBox;

}

void LevelMake()
{
	struct EditBox_ far *EBox;

	if( !(EBox = new EditBox_[16]) ) return;

	EditLevel( EBox, 224, 114);

	Scr.SetSaveOn();
	spBoxWin(216, 85, 386, 396, "레벨 설정",
								 WIN_F_COLOR,WIN_B_COLOR,WLIGHTGRAY );
	Scr.SetSaveOff();

	hgotoxy(29,8);
	hsetbkcolor(WLIGHTGRAY);
	hsetcolor(WYELLOW);
	hputs("점수/레벨/시간/다운");
	hsetcolor(WWHITE);
	hsetbkcolor(WLIGHTGREEN);

	int flag = spEditBox( EBox, WLIGHTGRAY );

	Scr.Restore();
	if (flag != -1)
		 for (int i=0;i<=14;i++)
				CopyString (Level[i], EBox[i].munja);
	delete[] EBox;
}

void EditLevel( struct EditBox_ far *EBox, int ScrX, int ScrY)
{
	spEditBoxInit( ScrX, ScrY+=16, EBox[0], Level[0], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[1], Level[1], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[2], Level[2], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[3], Level[3], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[4], Level[4], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[5], Level[5], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[6], Level[6], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[7], Level[7], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[8], Level[8], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[9], Level[9], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[10], Level[10], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[11], Level[11], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[12], Level[12], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[13], Level[13], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[14], Level[14], "9999/9999/9999/9999");
	spEditBoxInit( ScrX+70, ScrY+=20, EBox[15],"종료", "");
}

void EditProto( struct EditBox_ far *EBox, int Index, int ScrX, int ScrY)
{
	spEditBoxInit( ScrX, ScrY, EBox[0], Protocol[Index].Exec,
										"EEEEEEEEEEEE");
	spEditBoxInit( ScrX, ScrY, EBox[1], Protocol[Index].Up,
										"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEE");
	spEditBoxInit( ScrX, ScrY, EBox[2], Protocol[Index].Dn,
										"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEE");
	spEditBoxInit( ScrX, ScrY, EBox[3], "종료", "" );
}

void kmPuts(int x1,int y1,char *String)
{
	 int change=0,mode,col,temp1=hgetbkcolor(), temp2=hgetcolor();
	 hgotoxy(x1,y1);

	 while ( *String ) {
		 if ( ( *String == '@' ) || ( *String == '#') )
		 {
			 if ( *String++ == '@' ) mode = 1; else mode =0;
			 if ( ( *String == '1' ) && *(String+1) >= '0' && *(String+1) <='5' )
			 {
					switch ( *(++String) ) {
						case '0' : col = WLIGHTGREEN; break;
						case '1' : col = WCYAN; break;
						case '2' : col = WLIGHTRED; break;
						case '3' : col = WMAGENTA; break;
						case '4' : col = WYELLOW; break;
						case '5' : col = WWHITE;
					}
					change = 1;
					String++;
			 }
			 else
			 if ( ( *String  >= '0') && ( *String <= '9') )
			 {
					switch ( *String++ ) {
						case '0' : col = WBLACK; break;
						case '1' : col = WDARKBLUE; break;
						case '2' : col = WDARKGREEN; break;
						case '3' : break;
						case '4' : col = WDARKRED; break;
						case '5' : break;
						case '6' : break;
						case '7' : col = WLIGHTGRAY; break;
						case '8' : col = WDARKGRAY; break;
						case '9' : col = WLIGHTBLUE;
					}
					change = 1;
			 }
			 if ( change == 1 ) {
				 if ( mode == 1 )  hsetcolor(col);
				 if ( mode == 0 ) hsetbkcolor(col);
				 change = 0;
			 }
		 }
		 else hputch(*String++);
	 }
	 hsetbkcolor(temp1);  hsetcolor(temp2);
}
  
