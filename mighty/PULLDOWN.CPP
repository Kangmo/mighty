#include "hanbgi.h"
#include "han240.h"
#include "hanmeq.h"
#include "hanmou.h"
#include "danbi.h"
#include <bios.h>
#include <conio.h>
#include <fstream.h>
#define SCRX 15
#define SCRY 10
#define SMX 4
#define SMY 5
#define MBC WLIGHTGREEN
#define MBKC WLIGHTGRAY
#define MAXMENU 300
#define GABX 4
#define MLINES 24
#define MAXX 7
#define SMEY 9
#define SMEX 40
#define NCDLINECOLOR WDARKGRAY
#define UPBARSTARTY 44
#define DNBARSTARTY 435
#define FS 127
#define VER 100
void Tempfunc()
{}

void MightyIs(), MailTo(), DosShell(), ExitPro(), Getport(), Getspeed(),
	  Getparity(), Getdata(), Getstop(), GetWaitInit(), GetLocalInit(),
	  GetInitGab(), GetsName(), GetsId(), GetbName(), GetInstDir(),
	  GetDownDir(), GetAnsiDir(),GetArcDir(),
	  GetLoginId(), GetSonnimLev(), GetJoinLev(), GetBbsPoint(),
	  GetUpPoint(), GetUpSizeRate(), GetUpTimeRate(), GetHanFontType(),
	  GetEngFontType(),GetHanBoard(), GetPeopleNum(), GetInputLimTime(),
	  GetVirDetect(), GetVirOrder(), GetHackDetect(), GetHackWord(),
	  GetOpMode(), GetDoNullModem(), GetOpStart(), GetOpEnd(), GetSmPass(),
	  MenuMake(), ProtoMake(), LevelMake(), GetSound(), GetSysopExist(),
	  GetFirstGrade(), GetGiveDnableSize(), GetSuccDnLoad(), GetFifo(),
	  GetFlow(), GetMinBbsSize(), GetMinPdsSize(), GetMinSpeed(),
	  GetUsePartTime(), GetEmulPro(), GetEditPro();
void ScreenInit();
void EditLevel( struct EditBox_ far *, int, int);
void ProtoEditBox(int );
void EditProto( struct EditBox_ far *, int, int, int );
void CopyString( char *, char *);
void EditMenu(void);
void ReadProtoFile();
int multi(int, int );
void kmPuts(int ,int ,char *);


void (*Embank[7][16])()={
				{MightyIs,MailTo,DosShell,Tempfunc,ExitPro,0},
				{Getport,Getspeed,Getparity,Getdata,Getstop,GetFifo,
				 GetFlow,Tempfunc, GetWaitInit,GetLocalInit,GetInitGab,
				 Tempfunc,GetMinSpeed,0},
				{GetsName,GetsId,GetbName,Tempfunc,GetSysopExist,
				 GetSound,Tempfunc,GetInstDir,GetDownDir,
				 GetAnsiDir,GetArcDir,0},
				{GetLoginId, GetSonnimLev, GetJoinLev, GetFirstGrade, Tempfunc,
				 GetBbsPoint, GetUpPoint, GetMinBbsSize, GetMinPdsSize, GetUpSizeRate,
				 GetUpTimeRate, GetGiveDnableSize, 0},
				{GetHanFontType, GetEngFontType, GetHanBoard, GetPeopleNum,
				 GetInputLimTime, Tempfunc, GetVirDetect, GetVirOrder,
				 GetHackDetect, GetHackWord, GetEmulPro, GetEditPro, Tempfunc,
				 GetSuccDnLoad, 0},
				{GetOpMode, GetDoNullModem, GetUsePartTime, GetOpStart, GetOpEnd, Tempfunc, GetSmPass,0},
				{MenuMake,ProtoMake,LevelMake,0}
};

//---------------------------------------------------------------------------
struct M {
		int X;
		int Color;
		int Head;
		int Grade;
		int Close;
		int RunNo;
		char Index[7];
		char Title[21];
		char Type[9];
		char Go[9];
		char AnsiFile[9];
		char SysId[9];
		char Level[5];
		char Point[5];
		char Pass[9];
		unsigned f2,f3,f4,f5,f6: 1;
};

struct Proto {
		char Exec[13];
		char Up[31];
		char Dn[31];
		};


M Menu[MAXMENU+1];
Proto Protocol[10];

char sName[11]="김강모",sId[9]="SYSOP",bName[11]="HAHA",
		 InstDir[41]="C:\\MIGHTY",
		 DownDir[41]="C:\\MIGHTY\\DOWN", AnsiDir[41]="C:\\MIGHTY\\ANSI",
		 ArcDir[41]="C:\\UTIL\\ARC", WaitInit[61]="ATZ", LocalInit[61]="ATZ",
		 LoginId[11]="마이티",
		 VirOrder[41]="C:\\UTIL\\VACCINE\\TV.EXE",
		 HackWord[41]="hack Hack HACK troy Troy TROY",
		 SmPass[9]="puhaha", SonnimLev[5]="30  ", JoinLev[5]="50  ",
		 BbsPoint[6]="3  점", UpPoint[6]="5  점", UpSizeRate[4]="2배",
		 UpTimeRate[4]="1배", InputLimTime[4]="5분",
		 OpStart[9]="23시30분", OpEnd[9]="06시00분",InitGab[4]="5분";
int    Version=100,port=2, speed=6, parity=0, data=1, stop=0,
		 HanFontType=1, EngFontType=1, VirDetect=0,
		 HackDetect=0, OpMode=0, PeopleNum=0,
		 HanBoard=0,LevelNo,DoNullModem=0,Sound=1,SysopExist=1,
		 FirstGrade=0, GiveDnableSize=0, SuccDnLoad=1, Fifo=2, Flow=0;
char   MinBbsSize[5]="0   ", MinPdsSize[5]="0   ",
		 MinSpeed[9]="0    BPS";
int    UsePartTime=0;
char   EmulPro[41]="c:\\i\\i.exe";
char   EditPro[41]="c:\\utlt\\u.exe";
char Level[15][24]  = {
											"   0/  30/  20/   0",
											"   0/  50/  30/ 200",
											"  10/ 100/  35/ 300",
											"  20/ 200/  40/ 350",
											"  40/ 300/  45/ 400",
											"  60/ 400/  50/ 450",
											"  80/ 500/  55/ 500",
											" 100/ 600/  60/ 550",
											" 130/ 700/  65/ 600",
											" 200/ 800/  70/ 650",
											" 300/ 900/  75/ 700",
											" 400/1000/ 120/1000",
											"5000/2000/ 180/2000",
											"6000/5000/ 180/4000",
											"9000/9000/1000/9000"
											};

void ReadDatum(void)
{
	int j,count;
	char ch, number[7];

	fstream InFile("Mighty.cfg",ios::in);
	if (!InFile) return;

	 count = -1; Version=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 Version += (number[j]-48)*multi(10, (count-j));

	 count = -1; port=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 port += (number[j]-48)*multi(10, (count-j));

	 count = -1; speed=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 speed += (number[j]-48)*multi(10, (count-j));

	 count = -1; parity=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		parity += (number[j]-48)*multi(10, (count-j));

	 count = -1; data=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 data += (number[j]-48)*multi(10, (count-j));

	 count = -1; stop=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 stop += (number[j]-48)*multi(10, (count-j));

	 count = -1; HanFontType=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 HanFontType += (number[j]-48)*multi(10, (count-j));

	 count = -1; EngFontType=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 EngFontType += (number[j]-48)*multi(10, (count-j));

	 count = -1; VirDetect=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 VirDetect += (number[j]-48)*multi(10, (count-j));

	 count = -1; HackDetect=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 HackDetect += (number[j]-48)*multi(10, (count-j));

	 count = -1; OpMode=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 OpMode += (number[j]-48)*multi(10, (count-j));

	 count = -1; PeopleNum=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 PeopleNum += (number[j]-48)*multi(10, (count-j));

	 count = -1; HanBoard=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 HanBoard += (number[j]-48)*multi(10, (count-j));

	 count = -1; LevelNo=0;
	 while (InFile.get(ch), ch != FS) number[++count] = ch;
	 for (j=0; j<=count; j++)
		 LevelNo += (number[j]-48)*multi(10, (count-j));

		 count = -1;
		 while (InFile.get(ch), ch != FS) sName[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) sId[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) bName[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) InstDir[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) DownDir[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) AnsiDir[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) ArcDir[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) WaitInit[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) LocalInit[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) LoginId[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) VirOrder[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) HackWord[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) SmPass[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) SonnimLev[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) JoinLev[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) BbsPoint[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) UpPoint[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) UpSizeRate[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) UpTimeRate[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) InputLimTime[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) OpStart[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) OpEnd[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) InitGab[++count]=ch;

		 count = -1; DoNullModem=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 DoNullModem += (number[j]-48)*multi(10, (count-j));

		 count = -1; Sound=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 Sound += (number[j]-48)*multi(10, (count-j));

		 count = -1; SysopExist=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 SysopExist += (number[j]-48)*multi(10, (count-j));

		 count = -1; FirstGrade=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 FirstGrade += (number[j]-48)*multi(10, (count-j));

		 count = -1; GiveDnableSize=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 GiveDnableSize += (number[j]-48)*multi(10, (count-j));

		 count = -1; SuccDnLoad=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 SuccDnLoad += (number[j]-48)*multi(10, (count-j));

		 count = -1; Fifo=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 Fifo += (number[j]-48)*multi(10, (count-j));

		 count = -1; Flow=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 Flow += (number[j]-48)*multi(10, (count-j));

		 count = -1;
		 while (InFile.get(ch), ch != FS) MinBbsSize[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) MinPdsSize[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) MinSpeed[++count]=ch;

		 count = -1; UsePartTime=0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
		 UsePartTime += (number[j]-48)*multi(10, (count-j));

		 count = -1;
		 while (InFile.get(ch), ch != FS) EmulPro[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) EditPro[++count]=ch;

		 while( InFile.get(ch), ch!='\n');

		 for (int i=0; i<15; i++)
		 {
			 count = -1;
			 while (InFile.get(ch), ch != '\n') Level[i][++count]=ch;
		 }

	 InFile.close();
}
void SaveDatum(void)
{
	int i;
	if (access("MIGHTY.cfg",0)!=-1)
		if (remove("MIGHTY.cfg")==-1)
		{
			closehan();
			printf("ERROR : Can't over write to mighty.cfg");
			exit(0);
		}
	Version=VER;
	fstream OutFile("Mighty.cfg",ios::out);
	for (i=0; i<15; i++)
		if ( !strcmp( Level[LevelNo=i], "    /    /    /    ") ) break;
	if ( strcmp( Level[14], "    /    /    /    ") ) LevelNo=15;
	OutFile<< Version<< char(FS)<< port<< char(FS)<< speed<< char(FS)<< parity<< char(FS);
	OutFile<< data<< char(FS)<< stop<< char(FS)<< HanFontType<< char(FS);
	OutFile<< EngFontType<< char(FS)<< VirDetect<< char(FS);
	OutFile<< HackDetect<< char(FS)<< OpMode<< char(FS)<< PeopleNum<< char(FS);
	OutFile<< HanBoard<< char(FS)<<LevelNo<<char(FS)<< sName<< char(FS)<< sId<< char(FS);
	OutFile<< bName<< char(FS)<< InstDir<< char(FS)<< DownDir<<char(FS) ;
	OutFile<< AnsiDir<< char(FS)<< ArcDir<< char(FS)<< WaitInit<< char(FS);
	OutFile<< LocalInit<< char(FS);
	OutFile<< LoginId<< char(FS)<< VirOrder<< char(FS);
	OutFile<< HackWord<< char(FS)<< SmPass<< char(FS)<< SonnimLev<< char(FS);
	OutFile<< JoinLev<< char(FS)<< BbsPoint << char(FS);
	OutFile<< UpPoint<< char(FS)<< UpSizeRate <<char(FS)<< UpTimeRate<< char(FS);
	OutFile<< InputLimTime<< char(FS)<< OpStart << char(FS);
	OutFile<< OpEnd<< char(FS)<< InitGab<<char(FS)<< DoNullModem << char(FS);
	OutFile<< Sound<< char(FS)<< SysopExist<< char(FS)<< FirstGrade<< char(FS);
	OutFile<< GiveDnableSize << char(FS)<< SuccDnLoad<< char(FS);
	OutFile<< Fifo<<char(FS)<< Flow<< char(FS);
	OutFile<< MinBbsSize<< char(FS)<< MinPdsSize<< char(FS);
	OutFile<< MinSpeed<< char(FS)<<UsePartTime<<char(FS);
	OutFile<< EmulPro<<char(FS)<< EditPro<<char(FS)<<'\n';

	for (i=0; i<15; i++)  OutFile<< Level[i] <<'\n';
	OutFile.close();
}
class PullDown_ far * PD;

//---------------------------------------------------------------------------


void PullDownRtn(void);
void userinithan(void);


void main(void)
{
		 if (spDanbiInit(0L) == -1) return;
		 userinithan();
		 meq_init (MOU_ARROW16);
		 meq_show();
	 ReadDatum();
		 ReadProtoFile();
		 PullDownRtn();
		 mou_close();
}

void userinithan()
{
		 LINK_EGA_hputfont8x16();
		 LINK_EGA_hputfont16x16();
		 inithanlib( BGIMODE, HANDETECT, HAN8GD1, ENGGD5);
		 SELECT_hputfont8x16(AUTOSELECT);
		 SELECT_hputfont16x16(AUTOSELECT);
		 hsetallcolormap();
		 hsetwindowspalette(0);
}


void PullDownRtn()
{
		 PD = new PullDown_(SCRX-5,hgetmaxpx()-5-SCRX, SCRY);
		 int pd_x, pd_y;

		 char far *PopTitle[] = {
								"마이티",
								"모뎀셋업",
								"운영셋업",
								"BBS 셋업",
								"부가셋업I",
								"부가셋업II",
								"편집기",
								""};
		 int PopX[] = {SCRX, SCRX+90, SCRX+180, SCRX+270, SCRX+360,
									 SCRX+450, SCRX+540, 0};
		 int PopState[] = { 1, 1, 1, 1, 1, 1, 1, 0};

		 char far *PopMenu[7][16] = {
						 {
							 "마이티는..",
							 "제  작  자",
							 "도  스  쉘",
							 "LINE",
							 "끝  내  기",
							 ""},
						 {
							 "모 뎀  포 트",
							 "모 뎀  속 도",
							 "패리티  비트",
							 "데이타  비트",
							 "정 지  비 트",
							 " 16550 FIFO ",
							 "흐 름  제 어",
							 "LINE",
							 "대기중초기화",
							 "로컬  초기화",
							 "초기화  간격",
							 "LINE",
							 "최저접속속도",
							 ""},
						 {
							 "운영자   이름",
							 "운영자 아이디",
							 "비비에스 이름",
							 "LINE",
							 "운영자   유무",
							 "호스트   소리",
							 "LINE",
							 "설치된   경로",
							 "자료실   경로",
							 "안시화일 경로",
							 "압축화일 경로",
							 ""},
						 {
							 "로그인  아이디",
							 "손  님  레  벨",
							 "등 록 시  레벨",
							 "등 록 시  등급",
							 "LINE",
							 "게시판작성점수",
							 "자료업로드점수",
							 "게시물최저크기",
							 "자료 최저 크기",
							 "업로드용량보상",
							 "업로드시간보상",
							 "일일    다운제",
							 ""},
						 {
							 "한글  글꼴  지정",
							 "영문  글꼴  지정",
							 "한글  자판  지정",
							 "주민등록번호확인",
							 "입력  제한  시간",
							 "LINE",
							 "바이러스검사여부",
							 "바이러스검사명령",
							 "해킹자료검사여부",
							 "해킹자료  검색어",
							 "통신  에뮬레이터",
							 "에     디     터",
							 "LINE",
							 "연속  다운  로드",
							 ""},
						 {
							 "운 영  모 드",
							 "널모뎀  운영",
							 "파트타임사용",
							 "운영시작시간",
							 "운영종료시간",
							 "LINE",
							 "시삽메뉴암호",
							 ""},
						 {
							 "메    뉴",
							 "프로토콜",
							 "레    벨",
							 ""},
		 };

		 int PopMenuState[7][16] = {
								 { 1, 1, 1,-1, 1, 0},
								 { 1, 1, 1, 1, 1, 1, 1,-1, 1, 1, 1,-1, 1, 0},
								 { 1, 1, 1,-1, 1, 1,-1, 1, 1, 1, 1, 0},
								 { 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1, 1, 0},
								 { 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 1, 1,-1, 1, 0},
								 { 1, 1, 1, 1, 1,-1, 1, 0},
								 { 1, 1, 1, 0},
		 };
//PD->PD_( SCRX, 630, SCRY, WWHITE, WLIGHTBLUE );
		 PD->TopMenu = PopTitle;
		 PD->TopX = PopX;
		 PD->TopState = PopState;

		 for ( int i=0; i < 7; i++) {
				PD->PopMenuSet( PopMenu[i], i);
				PD->PopStateSet( PopMenuState[i], i);
		 }

		 ScreenInit();
		 int flag;
		 for (;;) {
							 flag = PD->TopMenuSelect();
							 pd_x = PD->X();
							 pd_y = PD->Y();
							 if ( flag != -1) (*Embank[pd_x][pd_y])();
		 };
}

void MightyIs()
{
	char *pWin[] = {
		" 새로운 호스트 마이티는 객체지향 ",
		" 기법을 사용, 제작 되었으므로 향 ",
		" 후 활발한 버젼업이 가능합니다.  ",
		" 마이티는 공개 소프트웨어이며, 상",
		" 업적 목적으로 쓰일 수 없습니다. ",
		"                                 ",
		"   Mighty Host   ver 0.02        ",
		"     (저) REFINED  SOFTWARE      ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "마이티는..", pWin, WWHITE, WLIGHTBLUE);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();

}

void MailTo()
{
	char *pWin[] = {
		"                             ",
		"    Mighty HOST  ver 1.00b   ",
		"     만  든  이 : 김강모     ",
		"     하이텔  Id : Capcom     ",
		"     나우콤  Id : refined    ",
		"                             ",
		"  고려대학교 컴퓨터학과 '95  ",
		"                             ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "제 작 자", pWin, WWHITE, WLIGHTBLUE);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}

void ScreenInit()
{
	spBar3d1(0,0,630,UPBARSTARTY-1);
	spBar3d1(0,UPBARSTARTY,630,DNBARSTARTY-1);
	PD->TopMenuInit(PD->X());
	spBar3d1(0,DNBARSTARTY,630,475);
	kmPuts(3,29,"#7@1신개념 호스트 MIGHTY @10ver 1.00b [ 향후 윈95용 멀티로 변환 예정 ] @9(저) @4김강모");
}
void DosShell()
{
	mou_hide();
	hrestorecrtmode();
	textcolor( WLIGHTGREEN );
	cputs( "<<<<");
	textcolor( WWHITE );
	cputs( "  MIGHTY  Ver 0.02 ...  ");
	textcolor( WLIGHTGREEN );
	cputs( " >>>>" );
	system("");
	hsetgraphmode();
	hsetwindowspalette(0);
	ScreenInit();
	mou_show();
}

void ExitPro()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"예",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "종료 하시겠습니까?",
																			pMessage, pItem, 0);
	Scr.SetSaveOff();
	Scr.Restore();

	if ( flag ==  1 ) {
										SaveDatum();
										delete PD;
										exit(0);
										}
}
void Getport()
{
	char far *pMenu[5] = {
				 "    1  번    ",
				 "    2  번    ",
				 "    3  번    ",
				 "    4  번    ",
				 ""};


	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 4, "모뎀 포트", pMenu, port);
	Scr.SetSaveOff();

	if ( flag != -1 ) port=flag;
	Scr.Restore();
}
void Getspeed()
{
	char far *pMenu[11]= {
				 "      300    ",
				 "      600    ",
				 "     1200    ",
				 "     2400    ",
				 "     4800    ",
				 "     9600    ",
				 "    19200    ",
				 "    38400    ",
				 "    57600    ",
				 "   115200    ",
				 ""};


	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 10, "모뎀속도", pMenu, speed);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) speed=flag;
	Scr.Restore();
}
void Getparity()
{
	char far *pMessage[] = {
							 "                       ",
							 ""};
	char far *pItem[] = {
								"없다",
								" ODD",
								"EVEN",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "패리티 비트", pMessage, pItem, parity);
	Scr.SetSaveOff();
	if ( flag != -1 ) parity = flag;
	Scr.Restore();
}

void Getdata()
{
	char far *pMessage[] = {
							 "                  ",
							 ""};
	char far *pItem[] = {
								"7 비트",
								"8 비트",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "데이터 비트", pMessage, pItem, data);
	Scr.SetSaveOff();
	if ( flag != -1 ) data = flag;
	Scr.Restore();
}
void Getstop()
{
	char far *pMessage[] = {
							 "                  ",
							 ""};
	char far *pItem[] = {
								"1 비트",
								"2 비트",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "스톱 비트", pMessage, pItem, stop);
	Scr.SetSaveOff();
	if ( flag != -1 ) stop =flag;
	Scr.Restore();
}

void GetWaitInit()
{
	int x=100,y=200;
	bool temp = _hangulmode;
	_hangulmode = false;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+502, y+50, "접속 대기중 초기화명령" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, WaitInit,
			 "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-60s" );
	_hangulmode = temp;

	Scr.Restore();
}
void GetLocalInit()
{
	int x=100,y=220;
	bool temp=_hangulmode;
	_hangulmode=false;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+342, y+50, "로컬 접속시 초기화명령" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, LocalInit,
			 "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	_hangulmode = temp;
	Scr.Restore();
}
void GetInitGab()
{
	int x=190,y=198;
	Scr.SetSaveOn();
	spBoxWin( x, y, x+136, y+50, "초기화 간격" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, InitGab,"9분", "%-3s" );
	Scr.Restore();
}

void GetsName()
{
	int x=190,y=140;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+120, y+50, "시삽 이름" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, sName,"XXXXXXXXXX", "%-10s" );
	Scr.Restore();
}
void GetsId()
{
	int x=190,y=156;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+136, y+50, "시삽 아이디");
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, sId,"XXXXXXXX", "%-8s" );
	Scr.Restore();
}
void GetbName()
{
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+120, y+50, "BBS 이름" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, bName,"XXXXXXXXXX", "%-10s" );
	Scr.Restore();
}
void GetInstDir()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "마이티가 설치된 경로" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, InstDir,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
	_hangulmode=temp;

	/*
	spBoxWin( 221, 210, 561, 264, "마이티가 설치된 경로");
	Scr.SetSaveOff();

	kmPuts(30,16,"#10                                        ");
	hgotoxy(30,16);
	hgetln(InstDir, 40);

	_hangulmode = temp;
	Scr.Restore();
	*/
}
void GetDownDir()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "자료실 경로" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, DownDir,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();

}
void GetAnsiDir()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "안시화일이 있는 경로" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, AnsiDir,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();

}
void GetArcDir()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "압축화일이 있는 경로" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, ArcDir,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();

}
void GetLoginId()
{
	int x=280,y=102;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+150, y+50, "로그인 아이디" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, LoginId,"XXXXXXXXXX", "%-10s" );
	Scr.Restore();
}
void GetSonnimLev()
{
	int x=280,y=118;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+126, y+50, "손님 레벨" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, SonnimLev,"9999", "%-4s" );
	Scr.Restore();
}
void GetJoinLev()
{
	int x=280,y=134;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+150, y+50, "등록시 레벨" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, JoinLev,"9999", "%-4s" );
	Scr.Restore();
}
void GetBbsPoint()
{
	int x=280,y=150;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+180, y+50, "게시판 작성점수" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, BbsPoint,"999점", "%-5s" );
	Scr.Restore();
}
void GetUpPoint()
{
	int x=280,y=166;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+186, y+50, "자료 업로드 점수" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, UpPoint,"999점", "%-5s" );
	Scr.Restore();
}
void GetUpSizeRate()
{
	int x=280,y=182;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+210, y+50, "업로드 용량 보상비" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, UpSizeRate,"9배", "%-3s" );
	Scr.Restore();
}
void GetUpTimeRate()
{
	int x=280,y=198;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+210, y+50, "업로드 시간 보상비" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, UpTimeRate,"9배", "%-3s" );
	Scr.Restore();
}
void GetHanFontType()
{
	 loadhanfont(1, "han8gd1.fnt", HINFO8X4X4);
	 loadhanfont(2, "han10md1.fnt", HINFO10X4X4);
	 loadhanfont(3, "han8gd2.fnt", HINFO8X4X4);
	 loadhanfont(4, "han8gd3.fnt", HINFO8X4X4);
	 loadhanfont(5, "han8gs1.fnt", HINFO8X4X4);
	 loadhanfont(6, "han8gs2.fnt", HINFO8X4X4);

		class PopUp_  SelectingFont;
		int flag;
		char far *pMenu[7] = {
					 "  한글 글꼴 1번  ",
					 "  한글 글꼴 2번  ",
					 "  한글 글꼴 3번  ",
					 "  한글 글꼴 4번  ",
					 "  한글 글꼴 5번  ",
					 "  한글 글꼴 6번  ",
					 ""};



		int PopMenuState[7] = { 1, 1, 1, 1, 1, 1, 0 };

		Scr.SetSaveOn();
			 spWin( 305, 139, 421, 245, "");
		Scr.SetSaveOff();

			 spBoxFill( 305, 139, 421, 245 , WLIGHTBLUE);
			 spBoxLine( 305, 139, 421, 245 , WWHITE,WDARKBLUE);

			 changehanfont(1);
			 kmPuts(40,10,"#9@15한글글꼴 1번");
			 changehanfont(2);
			 kmPuts(40,11,"#9@15한글글꼴 2번");
			 changehanfont(3);
			 kmPuts(40,12,"#9@15한글글꼴 3번");
			 changehanfont(4);
			 kmPuts(40,13,"#9@15한글글꼴 4번");
			 changehanfont(5);
			 kmPuts(40,14,"#9@15한글글꼴 5번");
			 changehanfont(6);
			 kmPuts(40,15,"#9@15한글글꼴 6번");

		Scr.SetSaveOn();
			 SelectingFont.PopUp( 150, 139, WWHITE, WBLACK, pMenu, PopMenuState);
		Scr.SetSaveOff();

		flag = SelectingFont.PopUpSelect();

		if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) )
		{
			 HanFontType = flag + 1;
			 changehanfont( HanFontType ) ;
			 int count = 1;
			 while (count ++ <= 6)
					if ( count != HanFontType ) releasehanfont(count);
			 ScreenInit();
		}
		else {
			 Scr.Restore();
			 Scr.Restore();
		}
}

void GetEngFontType()
{
	 loadengfont(1, "engmd2.fnt");
	 loadengfont(2, "engmd1.fnt");
	 loadengfont(3, "engmd3.fnt");
	 loadengfont(4, "engmd4.fnt");
	 loadengfont(5, "engmd6.fnt");
	 loadengfont(6, "enggd5.fnt");
	 loadengfont(7, "enggs6.fnt");


		class PopUp_  SelectingFont;
		int flag;
		char far *pMenu[8] = {
					 "  영문 글꼴 1번  ",
					 "  영문 글꼴 2번  ",
					 "  영문 글꼴 3번  ",
					 "  영문 글꼴 4번  ",
					 "  영문 글꼴 5번  ",
					 "  영문 글꼴 6번  ",
					 "  영문 글꼴 7번  ",
					 ""};



		int PopMenuState[8] = { 1, 1, 1, 1, 1, 1, 1, 0 };

		Scr.SetSaveOn();
			 spWin( 305, 139, 421, 261, "");
		Scr.SetSaveOff();

			 spBoxFill( 305, 139, 421, 261 , WLIGHTBLUE);
			 spBoxLine( 305, 139, 421, 261 , WWHITE,WDARKBLUE);

			 changeengfont(1);
			 kmPuts(40,10,"#9@15ENGLISH NO 1");
			 changeengfont(2);
			 kmPuts(40,11,"#9@15ENGLISH NO 2");
			 changeengfont(3);
			 kmPuts(40,12,"#9@15ENGLISH NO 3");
			 changeengfont(4);
			 kmPuts(40,13,"#9@15ENGLISH NO 4");
			 changeengfont(5);
			 kmPuts(40,14,"#9@15ENGLISH NO 5");
			 changeengfont(6);
			 kmPuts(40,15,"#9@15ENGLISH NO 6");
			 changeengfont(7);
			 kmPuts(40,16,"#9@15ENGLISH NO 7");

		Scr.SetSaveOn();
			 SelectingFont.PopUp( 150, 139, WWHITE, WBLACK, pMenu, PopMenuState);
		Scr.SetSaveOff();

		flag = SelectingFont.PopUpSelect();

		if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) )
		{
			 EngFontType = flag + 1;
			 changeengfont( EngFontType ) ;
			 int count = 1;
			 while (count ++ <= 7) if ( count != EngFontType ) releaseengfont(count);
			 ScreenInit();
		}
		else {
			 Scr.Restore();
			 Scr.Restore();
		}


}
void GetHanBoard()
{
	char far *pMessage[] = {
							 " 사용하고자 하는 한글 ",
							 " 자판을 결정해 주세요 ",
							 ""};
	char far *pItem[] = {
								"2벌식",
								"3벌식",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "한글 자판",pMessage, pItem, HanBoard);
	Scr.SetSaveOff();

	if ( flag != -1)
	{
		 HanBoard = flag;
		 if ( HanBoard == 0 )
		 {
			 hsethan389board( false );
			 hsethan2board( true );
		 }
		 else if ( HanBoard == 1 )
		 {
			 hsethan2board( false );
			 hsethan389board( true );
		 }
	}
	Scr.Restore();


}

void GetPeopleNum()
{
	char far *pMessage[] = {
							 "                    ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "주민등록번호 검사",
																		pMessage, pItem, PeopleNum);
	Scr.SetSaveOff();
	if ( flag != -1 ) PeopleNum = flag;
	Scr.Restore();
}

void GetInputLimTime()
{
	int x=350,y=220;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+144, y+50, "입력제한시간" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, InputLimTime,"9분", "%-3s" );
	Scr.Restore();
}
void GetVirDetect()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "바이러스 검사", pMessage, pItem, VirDetect);
	Scr.SetSaveOff();
	if ( flag != -1 ) VirDetect = flag;
	Scr.Restore();
}

void GetVirOrder()
{

	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "바이러스 검사 명령" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, VirOrder,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
	_hangulmode = temp;
}
void GetHackDetect()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "해킹,트로이 자료검사",
																			pMessage, pItem, HackDetect);
	Scr.SetSaveOff();
	if ( flag != -1 ) HackDetect = flag;
	Scr.Restore();
}

void GetHackWord()
{
	int x=145,y=220;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+342, y+50, "해킹자료 검사 단어" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, HackWord,
			 "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
}
void GetOpMode()
{
	char far *pMessage[] = {
							 "                             ",
							 ""};
	char far *pItem[] = {
								"공개",
								"반공개",
								"비공개",
								""};

	Scr.SetSaveOn();

	int flag = spChoiceItemWin(-1, -1, "운영 모드", pMessage, pItem, OpMode);
	Scr.SetSaveOff();
	if ( flag != -1 ) OpMode = flag;
	Scr.Restore();
}
void GetDoNullModem()
{
	char far *pMessage[] = {
							 "널모뎀통신은 모뎀없이 하는 통신입니다",
							 "전화선을 이용하여 운영할시 \"안한다\"로",
							 "설정하셔야 합니다.",
							 "널모뎀으로 호스트를 운영하시겠습니까?",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();

	int flag = spChoiceItemWin(-1, -1, "널모뎀 운영", pMessage, pItem, DoNullModem);
	Scr.SetSaveOff();
	if ( flag != -1 ) DoNullModem = flag;
	Scr.Restore();

}
void GetOpStart()
{
	int x=460,y=120;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+144, y+50, "운영시작시각" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, OpStart, "99시99분", "%-8s" );
	Scr.Restore();
}
void GetOpEnd()
{
	int x=460,y=116;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+144, y+50, "운영끝냄시각" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, OpEnd, "99시99분","%-8s" );
	Scr.Restore();
}
void GetSmPass()
{
	int x=460,y=140;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+120, y+50, "RDS 암호" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, SmPass, "XXXXXXXX", "%-8s" );
	Scr.Restore();
}
void GetSound()
{
	char far *pMessage[] = {
							 "BBS 운영시 호스트의 소리",
							 "를 꺼놓겠습니까?  켜놓겠",
							 "습니까?",
							 ""};
	char far *pItem[] = {
								"끔",
								"켬",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "호스트 소리",
																			pMessage, pItem, Sound);
	Scr.SetSaveOff();
	if ( flag != -1 ) Sound = flag;
	Scr.Restore();
}
void GetSysopExist()
{
	char far *pMessage[] = {
							 "                  ",
							 ""};
	char far *pItem[] = {
								"없음",
								"있음",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "운영자 유무",
																			pMessage, pItem, SysopExist);
	Scr.SetSaveOff();
	if ( flag != -1 ) SysopExist = flag;
	Scr.Restore();
}
void GetFirstGrade()
{
	char far *pMenu[11]= {
								"   사용중지회원   ",
								"     비 회 원     ",
								"     회 원  3     ",
								"     회 원  2     ",
								"     회 원  1     ",
								"     정 회 원     ",
								"     부운영자     ",
								"     운 영 자     ",
								""};

	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 8, "등록시  등급", pMenu, FirstGrade);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) FirstGrade=flag;
	Scr.Restore();
}
void GetGiveDnableSize()
{
	char far *pMessage[] = {
							 "                  ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "일일 다운제 사용",
																			pMessage, pItem, GiveDnableSize);
	Scr.SetSaveOff();
	if ( flag != -1 ) GiveDnableSize = flag;
	Scr.Restore();
}
void GetSuccDnLoad()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "연속 다운로드 사용",
																			pMessage, pItem, SuccDnLoad);
	Scr.SetSaveOff();
	if ( flag != -1 ) SuccDnLoad = flag;
	Scr.Restore();
}
void GetFifo()
{
	char far *pMenu[11]= {
								"   사용 안함   ",
								"    1 byte     ",
								"    4 bytes    ",
								"    8 bytes    ",
								"   14 bytes    ",
								""};

	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 5, "16550 FIFO", pMenu, Fifo);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) Fifo=flag;
	Scr.Restore();
}
void GetFlow()
{
	char far *pMenu[11]= {
								"         사용  안함          ",
								"     하드 웨어  흐름제어     ",
								"     소프트웨어 흐름제어     ",
								"         둘다  사용          ",
								""};

	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 4, "흐름 제어(Flow Control)", pMenu, Flow);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) Flow=flag;
	Scr.Restore();
}
void GetMinBbsSize()
{
	int x=250,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+240, y+50, "최저게시물크기 (글자수)" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, MinBbsSize,"9999", "%-4s" );
	Scr.Restore();
}
void GetMinPdsSize()
{
	int x=250,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+240, y+50, "최저 자료 크기 (KB단위)" );
	Scr.SetSaveOff();
	spGetMunja( x+10, y+29, MinPdsSize,"9999", "%-4s" );
	Scr.Restore();
}
void GetMinSpeed()
{
	int x=250,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+160, y+50, "최저 접속속도" );
	Scr.SetSaveOff();
	spGetMunja( x+10, y+29, MinSpeed,"99999BPS", "%-8s" );
	Scr.Restore();
}
void GetUsePartTime()
{
	char far *pMessage[] = {
							 "                      ",
							 ""};
	char far *pItem[] = {
								"안한다",
								"한다",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "파트타임 사용여부",
																			pMessage, pItem, UsePartTime);
	Scr.SetSaveOff();
	if ( flag != -1 ) UsePartTime = flag;
	Scr.Restore();
}
void GetEmulPro()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "통신 에뮬레이터 ( PATH까지 모두)" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, EmulPro,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
	_hangulmode=temp;
}
void GetEditPro()
{
	bool temp = _hangulmode;
	_hangulmode = false;
	int x=190,y=172;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+360, y+50, "외부 에디터 ( PATH까지 모두)" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, EditPro,
					"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%-40s" );
	Scr.Restore();
	_hangulmode=temp;
}
//----------------------------------------------------------------------
//                MENU  MAKE   PART
	 int no=0, MaxNo = 0;

void CopyString( char *cp1, char *cp2)
{
	while (*cp1++ = *cp2++);
}

void MenuScreenInit()
{
	spBar3d1(0,0,630,62);
	spBar3d1(0,63,630,475);
	kmPuts(4,2,"#7@15마이티 호스트 ver 0.02  @13메뉴 편집기               @15 (@14C@15)@1 REFINED SOFTWARE ");
	kmPuts(4,3,"#7@10INSERT@15 : @9메뉴추가   @11DEL @15:@9 메뉴삭제   @12ENTER @15: @9메뉴편집  @14 화살표키 @15: 이동 ");
}
void TopMenuInit()
{

			 Menu[1].X = 1;
			 Menu[1].Color = WYELLOW ;
			 Menu[1].RunNo = 0;
			 CopyString( Menu[1].Index ,"000000");
			 CopyString( Menu[1].Title ,"톱 메 뉴            ");
			 CopyString( Menu[1].Type ,"SUBMENU");
			 CopyString( Menu[1].Go , "TOP     ");
			 CopyString( Menu[1].Level ,"0000");
			 CopyString( Menu[1].Point ,"0000");
			 Menu[1].Grade = 0;
			 Menu[1].Close = 0;
			 no++;
			 MaxNo++;

}

void InitMenu(int fr, int to)
{
		for (int i=fr; i <= to; i++) {
			 Menu[i].X = 0;
			 for (int j=0; j<6; j++) Menu[i].Index[j] = '0';
			 Menu[i].Index[6] = 0;
			 Menu[i].Head = 0;
			 for (j=0; j< 21; j++) Menu[i].Title[j] = 0;
			 for (j=0; j< 9; j++)
			 {
					 Menu[i].Type[j] = 0;
					 Menu[i].Go[j] = 0;
					 Menu[i].AnsiFile[j] = 0;
					 Menu[i].SysId[j] = 0;
					 Menu[i].Pass[j]=0;
			 }
			 for (j=0; j< 5; j++) {
					 Menu[i].Level[j] = 0;
					 Menu[i].Point[j] = 0;
			 }
			 Menu[i].Grade = 1;
			 Menu[i].Close = 0;
			 Menu[i].Color = 0;
			 Menu[i].RunNo = 0;
			 Menu[i].f2 = 0;
			 Menu[i].f3 = 0;
			 Menu[i].f4 = 0;
			 Menu[i].f5 = 0;
			 Menu[i].f6 = 0;
		}

}

void BitFieldInit_Ins()
{
	 if (no<=2) return;
	 int m,i,j,k,flag=0;
	 k=no;
	 for ( i=2; i <= Menu[k].X -1; i++) {
			 for ( j=k; j <= MaxNo; j++)
			 {
					if (Menu[j].X == i ) flag=1;
					if (flag==1) break;
			 }
			 for (m = j; m >= k; m--) if (Menu[j].X > Menu[m].X) flag=0;
			 switch ( i ) {
				 case 2 : Menu[k].f2= flag?1:0;  break;
				 case 3 : Menu[k].f3= flag?1:0;  break;
				 case 4 : Menu[k].f4= flag?1:0;  break;
				 case 5 : Menu[k].f5= flag?1:0;  break;
				 case 6 : Menu[k].f6= flag?1:0;
			 }
			 flag=0;
		}
}
void BitFieldInit_Del()
{
	 if (no<=2) return;
	 int m,i,j,k,flag=0;
	 for ( j=no-1;j>=2;j--) if (Menu[no].X==Menu[j].X) break;
	 for (k=j; k<=no; k++) {
		 for ( i=2; i <= Menu[k].X -1; i++) {
			 for ( j=k; j <= MaxNo; j++)
			 {
					if (Menu[j].X == i ) flag=1;
					if (flag==1) break;
			 }
			 for (m = j; m >= k; m--) if (Menu[j].X > Menu[m].X) flag=0;
			 switch ( i ) {
				 case 2 : Menu[k].f2= flag?1:0;  break;
				 case 3 : Menu[k].f3= flag?1:0;  break;
				 case 4 : Menu[k].f4= flag?1:0;  break;
				 case 5 : Menu[k].f5= flag?1:0;  break;
				 case 6 : Menu[k].f6= flag?1:0;
			 }
			 flag=0;
		 }
	 }
}
void NotSavedOnHard()
{
	char *pWin[] = {
		" 하드 디스크에는 저장하지 ",
		" 않고 메모리에만  남겨 놓 ",
		" 았습니다.                ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "알려 드립니다", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}

int multi(int x1,int x2)
{
	 if (x2==0) return 1;
	 while (x2-- > 1) x1 *=x1;
	 return x1;
}

void ReadMenuFile()
{
	 int i,j,count;
	 char ch,number[7];
	 fstream  InFile("MENUDATA.DAT",ios::in);
	 if (!InFile) return;

	 count = -1; MaxNo=0;
	 while (InFile.get(ch), ch != '\n') number[++count] = ch;
	 for (j=0; j<=count; j++)
		 MaxNo += (number[j]-48)*multi(10, (count-j));

	 for (i=1; i<= MaxNo; i++)
	 {
		 count = -1; Menu[i].X = 0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].X += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].Color =0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].Color += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].Head =0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].Head += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].Grade =0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].Grade += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].Close = 0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].Close += (number[j]-48)*multi(10, (count-j));

		 count = -1; Menu[i].RunNo = 0;
		 while (InFile.get(ch), ch != FS) number[++count] = ch;
		 for (j=0; j<=count; j++)
				Menu[i].RunNo += (number[j]-48)*multi(10, (count-j));

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].Index[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].Title[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].Type[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].Go[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].AnsiFile[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].SysId[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].Level[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].Point[++count]=ch;

		 count = -1;
		 while (InFile.get(ch), ch != FS) Menu[i].Pass[++count]=ch;

		 while (InFile.get(ch), ch != FS) Menu[i].f2= (ch=='1') ? 1 : 0;
		 while (InFile.get(ch), ch != FS) Menu[i].f3= (ch=='1') ? 1 : 0;
		 while (InFile.get(ch), ch != FS) Menu[i].f4= (ch=='1') ? 1 : 0;
		 while (InFile.get(ch), ch != FS) Menu[i].f5= (ch=='1') ? 1 : 0;
		 while (InFile.get(ch), ch != '\n') Menu[i].f6= (ch=='1') ? 1 : 0;
	 }
	 InFile.close();
}
void SaveMenuFile()
{
	 int i;
	 fstream  OutFile("MENUDATA.DAT",ios::out);

	 OutFile << MaxNo << '\n';

	 for (i=1; i<= MaxNo; i++)
	 {
		 OutFile << Menu[i].X;
		 OutFile.put(FS);
		 OutFile << Menu[i].Color;
		 OutFile.put(FS);
		 OutFile << Menu[i].Head;
		 OutFile.put(FS);
		 OutFile << Menu[i].Grade;
		 OutFile.put(FS);
		 OutFile << Menu[i].Close;
		 OutFile.put(FS);
		 OutFile << Menu[i].RunNo;
		 OutFile.put(FS);
		 OutFile << Menu[i].Index;
		 OutFile.put(FS);
		 OutFile << Menu[i].Title;
		 OutFile.put(FS);
		 OutFile << Menu[i].Type;
		 OutFile.put(FS);
		 OutFile << Menu[i].Go;
		 OutFile.put(FS);
		 OutFile << Menu[i].AnsiFile;
		 OutFile.put(FS);
		 OutFile << Menu[i].SysId;
		 OutFile.put(FS);
		 OutFile << Menu[i].Level;
		 OutFile.put(FS);
		 OutFile << Menu[i].Point;
		 OutFile.put(FS);
		 OutFile << Menu[i].Pass;
		 OutFile.put(FS);
		 OutFile << ( (Menu[i].f2 == 1) ? '1':'0');
		 OutFile.put(FS);
		 OutFile << ( (Menu[i].f3 == 1) ? '1':'0');
		 OutFile.put(FS);
		 OutFile << ( (Menu[i].f4 == 1) ? '1':'0');
		 OutFile.put(FS);
		 OutFile << ( (Menu[i].f5 == 1) ? '1':'0');
		 OutFile.put(FS);
		 OutFile << ( (Menu[i].f6 == 1) ? '1':'0');
		 OutFile.put('\n');

	 }
	 OutFile.close();
}
void qSaveMenu()
{
	char far *pMessage[] = {
							 "   지금까지 작업한   ",
							 "   메뉴를   화일로   ",
							 "   저장하겠습니까?   ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"  예  ",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(310, 230,
							"저장하시겠습니까?", pMessage, pItem, 1);
	Scr.SetSaveOff();
	Scr.Restore();

	if ( flag == 1 ) SaveMenuFile();
	if ( flag == 0 ) NotSavedOnHard();

}

int ReallyEnd()
{
	char far *pMessage[] = {
							 " 메뉴 만들기를 그만 ",
							 " 하시겠습니까?      ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"  예  ",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1,
							"메뉴 만들기", pMessage, pItem, 0);
	Scr.SetSaveOff();
	if ( flag == 1 ) qSaveMenu();
	Scr.Restore();
	if ( flag != -1 ) return flag;

}
int ReallyDel()
{
	char far *pMessage[] = {
							 "                     ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"  예  ",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1,
							"정말 지우겠습니까?", pMessage, pItem, 0);
	Scr.SetSaveOff();
	Scr.Restore();
	if ( flag != -1 ) return flag;

}


void ReadProtoFile()
{
	 int i;
	 FILE *fProto=fopen("PROTOCOL.DAT","rb");
	 if (fProto==NULL) return;
	 fseek(fProto,0L,SEEK_SET);
	 for (i=0; i<10; i++) fread(&Protocol[i],sizeof(Proto),1,fProto);
	 fclose( fProto );
}

void SaveProtoFile()
{
	 int i;
	 FILE *fProto=fopen("PROTOCOL.DAT","wb");
	 if (fProto==NULL) return;
	 fseek(fProto,0L,SEEK_SET);
	 for (i=0; i<10; i++) fwrite(&Protocol[i],sizeof(Proto),1,fProto);
	 fclose( fProto );
}

void SaveProto()
{
	char far *pMessage[] = {
							 "   지금까지 작업한   ",
							 "   프로토콜 화일을   ",
							 "   저장하겠습니까?   ",
							 ""};
	char far *pItem[] = {
								"아니오",
								"  예  ",
								""};

	Scr.SetSaveOn();
	int flag = spChoiceItemWin(390, 170,
							"저장하시겠습니까?", pMessage, pItem, 1);
	Scr.SetSaveOff();
	Scr.Restore();

	if ( flag == 1 ) SaveProtoFile();
	if ( flag == 0 ) NotSavedOnHard();

}
/*
bool IsSameRunNum()
{
	hgotoxy(10,25); hprintf("max num--> %d",MaxNo);
	spWait();
	if ( MaxNo <= 2 ) return false;
	int i,fr,to;
	i = no;
	while ( Menu[i--].X == Menu[no].X );  fr = i ;
	i = fr;
	while ( Menu[i++].X == Menu[no].X );  to = i ;
	hgotoxy(60,25); hprintf("from %d to %d",fr,to);
	spWait();
	for (i=fr; i<=to; i++)
		 if ( Menu[no].RunNo == Menu[i].RunNo)
			 if (no != i) return true;
	return false;
}

void SameRunNum()
{
	char *pWin[] = {
		" 지금 입력하신 키는 이미 입력 ",
		" 된 키 입니다. 다른키를 눌러  ",
		" 주시기 바랍니다.             ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}
	*/
int	GetMenuRunNum()
{
	bool same=false;
	char RunNo[3];
	int x=220, y=215, ReadKey, ret=0;
	Scr.SetSaveOn();
	spBoxWin( x, y, x+244, y+50, "메뉴실행번호( 1 ~ 35 )" );
	Scr.SetSaveOff();
	if (Menu[no].RunNo == 0) strcpy(RunNo,"  ");
	else itoa(Menu[no].RunNo, RunNo, 10);
	while( !ret || ReadKey < 1 || ReadKey > 35 )
	{
	   ret = spGetMunja( x+108, y+29, RunNo, "99", "%-2s" );
		ReadKey = atoi(RunNo);
	}

	Scr.Restore();

	/*if ( same = IsSameRunNum() ) SameRunNum();*/
	return ReadKey;
}
void OutOfMenuMax()
{
	char *pWin[] = {
		" 현재 메뉴수가 사용 가능한  ",
		" 한계를 넘어 섰습니다.      ",
		" 다른 메뉴를 삭제한 후 메뉴 ",
		" 를 추가 하십시오.          ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();

}

void OutOfX()
{
	char *pWin[] = {
		" 톱메뉴 하위에 존재할 수 ",
		" 있는 메뉴수의 범위를 벗 ",
		" 어났습니다.             ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();

}

void CanNotDel1()
{
	char *pWin[] = {
		" 현재 지우려고 하는 메뉴는 ",
		" 서브메뉴이므로 지울 수 없 ",
		" 습니다. 먼저 하위 메뉴를  ",
		" 지우시기 바랍니다.        ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}

void CanNotDel2()
{
	char *pWin[] = {
		" 현재 지우려고 하는 메뉴는  ",
		" 톱메뉴 이므로 지울수 없습  ",
		" 니다.                      ",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "에러  발생", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();

}


void GetMenuType(void)
{
	 char far *pMenu[12] = {
				 "  서브  메뉴  ",
				 "  게  시  판  ",
				 "  자  료  실  ",
				 "  편지  쓰기  ",
				 "  편지  읽기  ",
				 "  대  화  실  ",
				 "  가입  메뉴  ",
				 "  회원  검색  ",
				 "  시간  은행  ",
				 "  동호회관리  ",
				 "  공지  사항  ",
				 ""};


	Scr.SetSaveOn();
	int flag=spPopUpWin( 100, -1, 14, "메뉴 종류", pMenu, 0);
	Scr.SetSaveOff();
	Scr.Restore();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) )
		switch (flag) {
			 case 0 : CopyString(Menu[no].Type,"SUBMENU");
								Menu[no].Color = WYELLOW;   break;
			 case 1 : CopyString(Menu[no].Type,"BBSMENU");
								Menu[no].Color = WCYAN;     break;
			 case 2 : CopyString(Menu[no].Type,"PDSMENU");
								Menu[no].Color = WLIGHTBLUE;     break;
			 case 3 : CopyString(Menu[no].Type,"WMAIL");
								Menu[no].Color = WDARKGREEN;     break;
			 case 4 : CopyString(Menu[no].Type,"RMAIL");
								Menu[no].Color = WDARKGREEN;     break;
			 case 5 : CopyString(Menu[no].Type,"CHAT");
								Menu[no].Color = WMAGENTA;     break;
			 case 6 : CopyString(Menu[no].Type,"JOIN");
								Menu[no].Color = WLIGHTRED;     break;
			 case 7 : CopyString(Menu[no].Type,"USERSEE");
								Menu[no].Color = WBLACK;     break;
			 case 8 : CopyString(Menu[no].Type,"TIME");
								Menu[no].Color = WBLACK;     break;
			 case 9 : CopyString(Menu[no].Type,"GROUP");
								Menu[no].Color = WDARKBLUE;     break;
			 case 10 : CopyString(Menu[no].Type,"NOTICE");
								Menu[no].Color = WDARKRED;     break;

		}
}
void GetGoOrder()
{
	int x=263,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+114, y+50, "GO 행선지" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, Menu[no].Go, "XXXXXXXX", "%-8s" );
	Scr.Restore();
}
void GetSysId()
{
	int x=200,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+140, y+50, "담당 아이디" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, Menu[no].SysId, "XXXXXXXX", "%-8s" );
	Scr.Restore();
}
int GetPass()
{
	int x=215,y=200,flag;

	Scr.SetSaveOn();
	flag = spBoxWin( x, y, x+122, y+50, "사용 암호" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, Menu[no].Pass, "XXXXXXXX", "%-8s" );
	Scr.Restore();
	if (flag==0) return -1;
}

void GetAnsiFile()
{
	int x=239,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+162, y+50, "안시 화일 이름" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, Menu[no].AnsiFile, "XXXXXXXX", "%-8s" );
	Scr.Restore();
}

void GetLevel()
{
	int x=225,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+190, y+50, "사용 가능한 레벨" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, Menu[no].Level, "9999", "%-8s" );
	Scr.Restore();
}
void GetPoint()
{
	int x=230,y=200;

	Scr.SetSaveOn();
	spBoxWin( x, y, x+180, y+50, "활동시 얻는 점수" );
	Scr.SetSaveOff();

	spGetMunja( x+10, y+29, Menu[no].Point, "9999", "%-8s" );
	Scr.Restore();
}

void GetGrade()
{
	char far *pMessage[] = {
							 " 이 메뉴를 사용 할 수 있는 회원의 ",
							 " 자격을 결정하여 주십시오.        ",
							 ""};
	char far *pItem[] = {
								"   사용중지회원   ",
								"     비 회 원     ",
								"     회 원  3     ",
								"     회 원  2     ",
								"     회 원  1     ",
								"     정 회 원     ",
								"    부  운영자    ",
								"     운 영 자     ",
								""};

	Scr.SetSaveOn();
	int flag=spPopUpWin( -1, -1, 8, "사용 가능 등급", pItem, Menu[no].Grade);
	Scr.SetSaveOff();

	if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) Menu[no].Grade=flag;
	Scr.Restore();
}

void GetClose()
{
	int mode =1;
	char far *pMessage[] = {
							 " 이 메뉴를 공개할 것인지 아니면 ",
							 " 비공개로 운영할 것인지  결정하 ",
							 " 여 주십시오.                   ",
							 ""};
	char far *pItem[] = {
								" 공개 ",
								"비공개",
								""};

PrintGetClose :
	if ( mode == 1 ) Scr.SetSaveOn();
	int flag = spChoiceItemWin(-1, -1, "공개 / 비공개",
													pMessage, pItem, Menu[no].Close);
	if ( mode == 1 ) Scr.SetSaveOff();
	mode = 0;

	if ( flag != -1 ) Menu[no].Grade = flag;
	if ( flag == 1 )
		if ( GetPass() == -1 ) goto PrintGetClose;
		else
		{
			Scr.Restore();
			Menu[no].Close = flag;
			return;
		}
	Menu[no].Close = flag;
	Scr.Restore();
}
void PrintBar(int num, int c)
{

	 int tempbkcolor,tempcolor;
	 int Mx = SMX + (Menu[num].X - 1) * GABX;
	 int My = SMY + (num % MLINES);
		 if (num % MLINES == 0) My += MLINES;
	 tempbkcolor = hgetbkcolor();
	 tempcolor = hgetcolor();
	 hsetbkcolor(c);
	 hgotoxy (Mx,My);
	 hputs("                    ");
	 hgotoxy (Mx,My);
	 if (c==MBC) {
			 hsetcolor(WBLACK);
			 if (Menu[num].RunNo != 0)
					hprintf( "[%i]",Menu[num].RunNo );
	 }
	 else
	 {
			 if (Menu[num].RunNo != 0)
					{
						hsetcolor( WWHITE );  hputs("[");
						hsetcolor( WLIGHTBLUE ); hprintf( "%i",Menu[num].RunNo );
						hsetcolor( WWHITE );  hputs("]");
					}
			 hsetcolor(Menu[num].Color);
	 }
	 hputs(Menu[num].Title);
	 hsetbkcolor(MBKC);
	 hsetcolor(WLIGHTBLUE);
	 hgotoxy(65,6);
	 hputs("인덱스번호");
	 hgotoxy(69,7);
	 hputs(Menu[no].Index);
	 hsetcolor(WBLACK);
	 hsetbkcolor(MBC);

	 if (Menu[num].f2 )
			rectangle( (SMX+GABX) *8 -17 , (My-1)*16, (SMX+GABX) *8 -16 , My*16-1 );
	 if (Menu[num].f3 )
			rectangle( (SMX+2*GABX) *8 -17 , (My-1)*16, (SMX+2*GABX) *8 -16 , My*16-1 );
	 if (Menu[num].f4 )
			rectangle( (SMX+3*GABX) *8 -17 , (My-1)*16, (SMX+3*GABX) *8 -16 , My*16-1 );
	 if (Menu[num].f5 )
			rectangle( (SMX+4*GABX) *8 -17 , (My-1)*16, (SMX+4*GABX) *8 -16 , My*16-1 );
	 if (Menu[num].f6 )
			rectangle( (SMX+5*GABX) *8 -17 , (My-1)*16, (SMX+5*GABX) *8 -16 , My*16-1 );

	 switch (Menu[num].Head) {
		 case 0 : break;
		 case 1 : rectangle(Mx*8-17,(My-1)*16,Mx*8-16,My*16-1);
							line(Mx*8-16,My*16-8,Mx*8+7-16,My*16-8);
							break;

		 case 2 : rectangle(Mx*8-17,(My-1)*16,Mx*8-16,My*16-8);
							line(Mx*8-16,My*16-8,Mx*8+7-16,My*16-8);

							break;
	 }
	 hsetbkcolor(tempbkcolor);
	 hsetcolor(tempcolor);


}
void CanNotGetRunNo()
{
	char *pWin[] = {
		" 톱메뉴의 메뉴실행번호는 ",
		" 바꿀 수 없습니다",
		"" };

	Scr.SetSaveOn();
		spMessageWin( -1, -1, "알려 드립니다", pWin, WWHITE, WLIGHTRED);
	Scr.SetSaveOff();
	spWait();
	Scr.Restore();
}
void GetRunNo()
{
	 int i;
	 if ( no==1 )
	 {
		  CanNotGetRunNo();
		  return;
	 }
	 Menu[no].RunNo = GetMenuRunNum();

	 if (no > 2)

	 for (i=2; i<  Menu[no].X ; i++)
	 {
		 for (int j=no-1; j>=2; j-- )
		 {
				if ( i == Menu[j].X )
					 if ( Menu[no].Index [i-2] == '0')
					 {
						  if (Menu[j].RunNo <= 9 )
							 Menu[no].Index[i-2] = Menu[j].RunNo + '0';
						  else  Menu[no].Index[i-2] = Menu[j].RunNo - 10 + 'A';
					 }
		 }
	 }

	 if (Menu[no].RunNo <= 9 )
		 Menu[no].Index[Menu[no].X -2] = Menu[no].RunNo + '0';
	 else  Menu[no].Index[Menu[no].X -2] = Menu[no].RunNo - 10 + 'A';
}
int GetTitle(int mode=0)
{
	int x=233,y=200,flag=0;
	char temp[21];

	hsetcolor(WBLACK);
	Scr.SetSaveOn();
	spBoxWin( x, y, x+182, y+50, "메뉴의 제목" );
	Scr.SetSaveOff();
	if (mode) {
		 CopyString(temp,Menu[no].Title);
		 for (int i=0; i<=20; i++) Menu[no].Title[i]=0;
	}
	flag = spGetMunja( x+10, y+29, Menu[no].Title,
													"XXXXXXXXXXXXXXXXXXXX", "%-20s" );
	if (mode && (flag==27)) CopyString(Menu[no].Title,temp);
	Scr.Restore();
	hsetcolor(WWHITE);
	return flag;
}

void PrintMenu( int start )
{

	 int end;
	 if (MaxNo == 0) return;
	 if (MaxNo - start < MLINES ) end = MaxNo;
	 else end = start + MLINES -1 ;

	 spFill( 10, 73, 620, 465 , WLIGHTGRAY);
	 for (int i = start; i <= end ;i++ ) PrintBar(i,MBKC);
}

void InsMenu()
{
	 char NewTitle[21],OriTitle[21];
	 if ( MaxNo >= MAXMENU ) { OutOfMenuMax(); return; }
	 if ( Menu[no].X == MAXX ) { OutOfX(); return; }
	 no++;
	 MaxNo++;

	 CopyString ( OriTitle, Menu[no].Title);
	 if (  GetTitle(1) == 27 ) {
			no--;
			MaxNo--;
			return;
	 }
	 else {
				 CopyString (NewTitle, Menu[no].Title);
				 CopyString (Menu[no].Title, OriTitle);
				}
	 for (int i = MaxNo-1 ; i >= no ; i--) Menu[i+1]=Menu[i];
	 InitMenu(no, no);
	 CopyString (Menu[no].Title,NewTitle);

	 Menu[no].X = Menu[no-1].X + 1;
	 if ( Menu[no].X == Menu[no+1].X ) Menu[no].Head = 1;
	 else Menu[no].Head = 2;

	 GetRunNo();

	 BitFieldInit_Ins();
	 PrintMenu( (no / MLINES) * MLINES + 1 );
	 PrintBar(no,MBC);
	 EditMenu();
}

void DelMenu()
{
	 if ( no < 1 ) return;
	 int temp,toModify;
	 int flag=0;
	 if (no == 1) {
			CanNotDel2();
			return;
	 }
	 if (no < MaxNo)
				if (Menu[no].X < Menu[no+1].X) {
				 CanNotDel1();
				 return;
			}

	 if (ReallyDel() != 1) return;

	 for (int i=no-1; i >= 1; i--) {
		 if (Menu[no].X == Menu[i].X) {
			 flag=1;
			 toModify=i;
			 break;
		 }
	 }
	 if (flag) for (i=toModify + 1; i < no; i++) if (Menu[i].X <Menu[no].X) flag=0;
	 if (flag)
	 {
		 flag=0;
		 for (i=no+1; i <= MaxNo; i++) {
			if (Menu[no].X == Menu[i].X) {
				flag=1;
				temp=i;
				break;
			}
		 }
		 if (flag) for (i=no + 1; i < temp; i++) if (Menu[i].X <Menu[no].X) flag=0;
		 if (flag) Menu[toModify].Head = 1;
		 else Menu[toModify].Head = 2;
	 }
	 for (i=no;i <= MaxNo; i++) Menu[i]=Menu[i+1];
	 InitMenu (MaxNo,MaxNo);
	 MaxNo--;
	 no--;

	 BitFieldInit_Del();
	 if (no % MLINES == 0)
			PrintMenu( ( no / MLINES - 1)* MLINES + 1);
	 else PrintMenu( (no / MLINES)* MLINES + 1);
	 PrintBar(no,MBC);
}

void EditMenu()
{
		class PopUp_  MenuMaking;
		int choonum,flag,mode=1;
		char far *pMenu[12] = {
					 "  메뉴 실행 번호  ",
					 "  메  뉴  이  름  ",
					 "  메  뉴  종  류  ",
					 "  Go 행선지 단어  ",
					 "  안  시  화  일  ",
					 "  활 동 시 점 수  ",
					 "LINE",
					 "  사용 가능 레벨  ",
					 "  사용 가능 등급  ",
					 "  담 당 아 이 디  ",
					 "  공  개  여  부  ",
					 ""};



	int PopMenuState[12] = { 1, 1, 1, 1, 1, 1,-1, 1, 1, 1, 1, 0 };


		if (mode ) Scr.SetSaveOn();
			 spWin( 305, 123, 495, 309, "");
		if (mode ) Scr.SetSaveOff();

PrintEditMenu :

	char Close[21];
	char    *Grade[] = {
								"사용중지회원",
								"  비 회 원  ",
								"  회 원  3  ",
								"  회 원  2  ",
								"  회 원  1  ",
								"  정 회 원  ",
								" 부  운영자 ",
								"  운 영 자  ",
								""};
		switch (Menu[no].Close) {
			case 0 : CopyString(Close,"공개");  break;
			case 1 : CopyString(Close,"비공개   / ");
							 CopyString(Close+11, Menu[no].Pass);
							 break;
			default : CopyString(Close+11, "   ");
		}
			 spBoxFill( 305, 123, 495, 309 , WLIGHTBLUE);
			 spBoxLine( 305, 123, 495, 231 , WWHITE,WDARKBLUE);
			 spBoxLine( 305, 232, 495, 309 , WWHITE,WDARKBLUE);

				 hsetbkcolor (WLIGHTBLUE);
				 hsetcolor (WWHITE);
						hgotoxy(40,9); hprintf("%2i",Menu[no].RunNo);
						hgotoxy(40,10); hputs(Menu[no].Title);
						hgotoxy(40,11); hputs(Menu[no].Type);
						hgotoxy(40,12); hputs(Menu[no].Go);
						hgotoxy(40,13); hputs(Menu[no].AnsiFile);
						hgotoxy(40,14); hputs(Menu[no].Point);
						hgotoxy(40,16); hputs(Menu[no].Level);
						hgotoxy(40,17); hputs(Grade[Menu[no].Grade]);
						hgotoxy(40,18); hputs(Menu[no].SysId);
						hgotoxy(40,19); hputs(Close);
				 hsetbkcolor (MBKC);
		if (mode) Scr.SetSaveOn();
			 MenuMaking.PopUp( 150, 123, WWHITE, WBLACK, pMenu, PopMenuState);
		if (mode) Scr.SetSaveOff();
		mode = 0;

		flag = MenuMaking.PopUpSelect();
		if ( (flag != -1) && (flag != LEFTARROW) && (flag != RIGHTARROW) ) choonum = flag;
		else  {
						Scr.Restore();
						Scr.Restore();
						PrintBar(no,MBC);
						return;
					}
		switch (choonum) {
			case 0 : GetRunNo();   break;
			case 1 : GetTitle() ;   break;
			case 2 : GetMenuType() ;   break;
			case 3 : GetGoOrder() ;  break;
			case 4 : GetAnsiFile() ;  break;
			case 5 : GetPoint() ;  break;
			case 7 : GetLevel() ;  break;
			case 8 : GetGrade() ;  break;
			case 9 : GetSysId() ;  break;
			case 10: GetClose();
		}
		goto PrintEditMenu;
}





void UpArr()
{
	if ( no <= 1 ) return;
	no--;

	if ( (( no % MLINES ) == 0 ) && ( no >= MLINES ) )  {
		 PrintMenu( no - MLINES + 1 );
		 PrintBar( no, MBC);
	}
	else {
				PrintBar(no+1,MBKC);
				PrintBar(no,MBC);
			 }
}
void DnArr()
{
	if ( no >= MaxNo )  return;
	no++;

	if ( ((no -1) % MLINES ) == 0 ) {
		 PrintMenu( no );
		 PrintBar( no, MBC);
	}
	else {
				PrintBar(no-1,MBKC);
				PrintBar(no,MBC);
			 }

}

int count=0;

void MenuMake()
{
	char ch;

	MenuScreenInit();
	setcolor(NCDLINECOLOR);
	if (count++==0) {
		InitMenu(0,MAXMENU);
		TopMenuInit();
		ReadMenuFile();
	}
	PrintMenu(1);
	PrintBar(no,MBC);
	int endroutine = 0;
	while ( endroutine == 0 )
		if ( bioskey(1) != 0 ) {
			ch=getch();
			switch(ch) {
				case 0 :
							ch = getch();
							switch(ch) {
								case 82 : InsMenu(); break;
								case 83 : DelMenu(); break;
								case 72 : UpArr();  break;
								case 80 : DnArr();
							}
							break;
				case 13 :  EditMenu();  break;
				case 27 :  if ( ReallyEnd() ) endroutine = 1;
			}
		}
	ScreenInit();
}
void ProtoMake()
{
	int mode = 1;
	char far *pMenu[11] = {
				 "   1 번 프로토콜   ",
				 "   2 번 프로토콜   ",
				 "   3 번 프로토콜   ",
				 "   4 번 프로토콜   ",
				 "   5 번 프로토콜   ",
				 "   6 번 프로토콜   ",
				 "   7 번 프로토콜   ",
				 "   8 번 프로토콜   ",
				 "   9 번 프로토콜   ",
				 "   10번 프로토콜   ",
				 ""};

ProtoMenu :

	if ( mode == 1 ) Scr.SetSaveOn();
	int flag=spPopUpWin( 450, 80, 10, "    프로토콜 편집기    ", pMenu, 0);
	if ( mode == 1 ) Scr.SetSaveOff();

	mode = 0;

	if ( flag == -1 ) {
		 SaveProto();
		 Scr.Restore();
		 return;
	}
	else ProtoEditBox(flag);
	goto ProtoMenu;

}
void ProtoEditBox(int Index)
{
	char *Title;
	struct EditBox_ far *EBox;
	if( !(EBox = new EditBox_[4]) ) return;

	char far *FieldTitles[] =
	{
		"실행화일 이름",
		"업 로 드 옵션",
		"다운로드 옵션",
		"종료",
		""
	};

	switch (Index) {
		case 0 : Title = "1 번 프로토콜 편집"; break;
		case 1 : Title = "2 번 프로토콜 편집"; break;
		case 2 : Title = "3 번 프로토콜 편집"; break;
		case 3 : Title = "4 번 프로토콜 편집"; break;
		case 4 : Title = "5 번 프로토콜 편집"; break;
		case 5 : Title = "6 번 프로토콜 편집"; break;
		case 6 : Title = "7 번 프로토콜 편집"; break;
		case 7 : Title = "8 번 프로토콜 편집"; break;
		case 8 : Title = "9 번 프로토콜 편집"; break;
		case 9 : Title = "10번 프로토콜 편집";
	}
	EditProto( EBox, Index, 0, 0);

	Scr.SetSaveOn();
	spTitleEditBoxWin( 100, 170,
				 Title, FieldTitles, EBox);
	Scr.SetSaveOff();

	Scr.Restore();

	CopyString(Protocol[Index].Exec, EBox[0].munja);
	CopyString(Protocol[Index].Up, EBox[1].munja);
	CopyString(Protocol[Index].Dn, EBox[2].munja);

	delete[] EBox;

}
void LevelMake()
{
	struct EditBox_ far *EBox;

	if( !(EBox = new EditBox_[16]) ) return;

	EditLevel( EBox, 224, 114);

	Scr.SetSaveOn();
	spBoxWin(216, 85, 386, 396, "레벨 설정",
								 WIN_F_COLOR,WIN_B_COLOR,WLIGHTGRAY );
	Scr.SetSaveOff();

	hgotoxy(29,8);
	hsetbkcolor(WLIGHTGRAY);
	hsetcolor(WYELLOW);
	hputs("점수/레벨/시간/다운");
	hsetcolor(WWHITE);
	hsetbkcolor(WLIGHTGREEN);

	int flag = spEditBox( EBox, WLIGHTGRAY );

	Scr.Restore();
	if (flag != -1)
		 for (int i=0;i<=14;i++)
				CopyString (Level[i], EBox[i].munja);
	delete[] EBox;
}
void EditLevel( struct EditBox_ far *EBox, int ScrX, int ScrY)
{
	spEditBoxInit( ScrX, ScrY+=16, EBox[0], Level[0], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[1], Level[1], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[2], Level[2], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[3], Level[3], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[4], Level[4], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[5], Level[5], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[6], Level[6], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[7], Level[7], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[8], Level[8], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[9], Level[9], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[10], Level[10], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[11], Level[11], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[12], Level[12], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[13], Level[13], "9999/9999/9999/9999");
	spEditBoxInit( ScrX, ScrY+=16, EBox[14], Level[14], "9999/9999/9999/9999");
	spEditBoxInit( ScrX+70, ScrY+=20, EBox[15],"종료", "");
}

void EditProto( struct EditBox_ far *EBox, int Index, int ScrX, int ScrY)
{
	spEditBoxInit( ScrX, ScrY, EBox[0], Protocol[Index].Exec,
										"EEEEEEEEEEEE");
	spEditBoxInit( ScrX, ScrY, EBox[1], Protocol[Index].Up,
										"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEE");
	spEditBoxInit( ScrX, ScrY, EBox[2], Protocol[Index].Dn,
										"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEE");
	spEditBoxInit( ScrX, ScrY, EBox[3], "종료", "" );
}

void kmPuts(int x1,int y1,char *String)
{
	 int change=0,mode,col,temp1=hgetbkcolor(), temp2=hgetcolor();
	 hgotoxy(x1,y1);

	 while ( *String ) {
		 if ( ( *String == '@' ) || ( *String == '#') )
		 {
			 if ( *String++ == '@' ) mode = 1; else mode =0;
			 if ( ( *String == '1' ) && *(String+1) >= '0' && *(String+1) <='5' )
			 {
					switch ( *(++String) ) {
						case '0' : col = WLIGHTGREEN; break;
						case '1' : col = WCYAN; break;
						case '2' : col = WLIGHTRED; break;
						case '3' : col = WMAGENTA; break;
						case '4' : col = WYELLOW; break;
						case '5' : col = WWHITE;
					}
					change = 1;
					String++;
			 }
			 else
			 if ( ( *String  >= '0') && ( *String <= '9') )
			 {
					switch ( *String++ ) {
						case '0' : col = WBLACK; break;
						case '1' : col = WDARKBLUE; break;
						case '2' : col = WDARKGREEN; break;
						case '3' : break;
						case '4' : col = WDARKRED; break;
						case '5' : break;
						case '6' : break;
						case '7' : col = WLIGHTGRAY; break;
						case '8' : col = WDARKGRAY; break;
						case '9' : col = WLIGHTBLUE;
					}
					change = 1;
			 }
			 if ( change == 1 ) {
				 if ( mode == 1 )  hsetcolor(col);
				 if ( mode == 0 ) hsetbkcolor(col);
				 change = 0;
			 }
		 }
		 else hputch(*String++);
	 }
	 hsetbkcolor(temp1);  hsetcolor(temp2);
}
